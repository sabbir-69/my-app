{"version":3,"file":"localStorage-crypto-store.js","names":["logger","MemoryCryptoStore","MigrationState","SESSION_BATCH_SIZE","E2E_PREFIX","KEY_END_TO_END_MIGRATION_STATE","KEY_END_TO_END_ACCOUNT","KEY_CROSS_SIGNING_KEYS","KEY_INBOUND_SESSION_PREFIX","KEY_INBOUND_SESSION_WITHHELD_PREFIX","KEY_ROOMS_PREFIX","KEY_SESSIONS_NEEDING_BACKUP","keyEndToEndSessions","deviceKey","keyEndToEndInboundGroupSession","senderKey","sessionId","keyEndToEndInboundGroupSessionWithheld","keyEndToEndRoomsPrefix","roomId","LocalStorageCryptoStore","exists","store","length","i","_store$key","key","startsWith","constructor","containsData","_this","_asyncToGenerator","getMigrationState","_this2","_getJsonItem","getJsonItem","NOT_STARTED","setMigrationState","migrationState","_this3","setJsonItem","countEndToEndSessions","txn","func","count","sessions","Object","keys","_getEndToEndSessions","fixedSessions","sid","val","entries","session","getEndToEndSession","_sessions$sessionId","getEndToEndSessions","_this$_getEndToEndSes","storeEndToEndSession","sessionInfo","getEndToEndSessionsBatch","_this4","result","_this4$store$key","split","values","push","deleteEndToEndSessionsBatch","_this5","deviceSessions","removeItem","getEndToEndInboundGroupSession","senderCurve25519Key","storeEndToEndInboundGroupSession","sessionData","countEndToEndInboundGroupSessions","_this6","getEndToEndInboundGroupSessionsBatch","_this7","sessionsNeedingBackup","key2","slice","needsBackup","deleteEndToEndInboundGroupSessionsBatch","_this8","k","getEndToEndRooms","prefix","markSessionsNeedingBackup","Promise","resolve","deleteAllData","getAccount","accountPickle","storeAccount","getCrossSigningKeys","getSecretStorePrivateKey","type","concat","storeSecretStorePrivateKey","doTxn","mode","stores","JSON","parse","getItem","e","log","message","stack","setItem","stringify"],"sources":["../../../src/crypto/store/localStorage-crypto-store.ts"],"sourcesContent":["/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger } from \"../../logger.ts\";\nimport { MemoryCryptoStore } from \"./memory-crypto-store.ts\";\nimport {\n    type CryptoStore,\n    type ISession,\n    type SessionExtended,\n    type ISessionInfo,\n    type IWithheld,\n    MigrationState,\n    type Mode,\n    type SecretStorePrivateKeys,\n    SESSION_BATCH_SIZE,\n    type InboundGroupSessionData,\n    type IRoomEncryption,\n} from \"./base.ts\";\nimport { type CrossSigningKeyInfo } from \"../../crypto-api/index.ts\";\n\n/**\n * Internal module. Partial localStorage backed storage for e2e.\n * This is not a full crypto store, just the in-memory store with\n * some things backed by localStorage. It exists because indexedDB\n * is broken in Firefox private mode or set to, \"will not remember\n * history\".\n */\n\nconst E2E_PREFIX = \"crypto.\";\nconst KEY_END_TO_END_MIGRATION_STATE = E2E_PREFIX + \"migration\";\nconst KEY_END_TO_END_ACCOUNT = E2E_PREFIX + \"account\";\nconst KEY_CROSS_SIGNING_KEYS = E2E_PREFIX + \"cross_signing_keys\";\nconst KEY_INBOUND_SESSION_PREFIX = E2E_PREFIX + \"inboundgroupsessions/\";\nconst KEY_INBOUND_SESSION_WITHHELD_PREFIX = E2E_PREFIX + \"inboundgroupsessions.withheld/\";\nconst KEY_ROOMS_PREFIX = E2E_PREFIX + \"rooms/\";\nconst KEY_SESSIONS_NEEDING_BACKUP = E2E_PREFIX + \"sessionsneedingbackup\";\n\nfunction keyEndToEndSessions(deviceKey: string): string {\n    return E2E_PREFIX + \"sessions/\" + deviceKey;\n}\n\nfunction keyEndToEndInboundGroupSession(senderKey: string, sessionId: string): string {\n    return KEY_INBOUND_SESSION_PREFIX + senderKey + \"/\" + sessionId;\n}\n\nfunction keyEndToEndInboundGroupSessionWithheld(senderKey: string, sessionId: string): string {\n    return KEY_INBOUND_SESSION_WITHHELD_PREFIX + senderKey + \"/\" + sessionId;\n}\n\nfunction keyEndToEndRoomsPrefix(roomId: string): string {\n    return KEY_ROOMS_PREFIX + roomId;\n}\n\nexport class LocalStorageCryptoStore extends MemoryCryptoStore implements CryptoStore {\n    public static exists(store: Storage): boolean {\n        const length = store.length;\n        for (let i = 0; i < length; i++) {\n            if (store.key(i)?.startsWith(E2E_PREFIX)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public constructor(private readonly store: Storage) {\n        super();\n    }\n\n    /**\n     * Returns true if this CryptoStore has ever been initialised (ie, it might contain data).\n     *\n     * Implementation of {@link CryptoStore.containsData}.\n     *\n     * @internal\n     */\n    public async containsData(): Promise<boolean> {\n        return LocalStorageCryptoStore.exists(this.store);\n    }\n\n    /**\n     * Get data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.getMigrationState}.\n     *\n     * @internal\n     */\n    public async getMigrationState(): Promise<MigrationState> {\n        return getJsonItem(this.store, KEY_END_TO_END_MIGRATION_STATE) ?? MigrationState.NOT_STARTED;\n    }\n\n    /**\n     * Set data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.setMigrationState}.\n     *\n     * @internal\n     */\n    public async setMigrationState(migrationState: MigrationState): Promise<void> {\n        setJsonItem(this.store, KEY_END_TO_END_MIGRATION_STATE, migrationState);\n    }\n\n    // Olm Sessions\n\n    public countEndToEndSessions(txn: unknown, func: (count: number) => void): void {\n        let count = 0;\n        for (let i = 0; i < this.store.length; ++i) {\n            const key = this.store.key(i);\n            if (key?.startsWith(keyEndToEndSessions(\"\"))) {\n                const sessions = getJsonItem(this.store, key);\n                count += Object.keys(sessions ?? {}).length;\n            }\n        }\n        func(count);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private _getEndToEndSessions(deviceKey: string): Record<string, ISessionInfo> {\n        const sessions = getJsonItem(this.store, keyEndToEndSessions(deviceKey));\n        const fixedSessions: Record<string, ISessionInfo> = {};\n\n        // fix up any old sessions to be objects rather than just the base64 pickle\n        for (const [sid, val] of Object.entries(sessions || {})) {\n            if (typeof val === \"string\") {\n                fixedSessions[sid] = {\n                    session: val,\n                };\n            } else {\n                fixedSessions[sid] = val;\n            }\n        }\n\n        return fixedSessions;\n    }\n\n    public getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (session: ISessionInfo) => void,\n    ): void {\n        const sessions = this._getEndToEndSessions(deviceKey);\n        func(sessions[sessionId] ?? {});\n    }\n\n    public getEndToEndSessions(\n        deviceKey: string,\n        txn: unknown,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void {\n        func(this._getEndToEndSessions(deviceKey) ?? {});\n    }\n\n    public storeEndToEndSession(deviceKey: string, sessionId: string, sessionInfo: ISessionInfo, txn: unknown): void {\n        const sessions = this._getEndToEndSessions(deviceKey) || {};\n        sessions[sessionId] = sessionInfo;\n        setJsonItem(this.store, keyEndToEndSessions(deviceKey), sessions);\n    }\n\n    /**\n     * Fetch a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndSessionsBatch(): Promise<null | ISessionInfo[]> {\n        const result: ISessionInfo[] = [];\n        for (let i = 0; i < this.store.length; ++i) {\n            if (this.store.key(i)?.startsWith(keyEndToEndSessions(\"\"))) {\n                const deviceKey = this.store.key(i)!.split(\"/\")[1];\n                for (const session of Object.values(this._getEndToEndSessions(deviceKey))) {\n                    result.push(session);\n                    if (result.length >= SESSION_BATCH_SIZE) {\n                        return result;\n                    }\n                }\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndSessionsBatch(sessions: { deviceKey: string; sessionId: string }[]): Promise<void> {\n        for (const { deviceKey, sessionId } of sessions) {\n            const deviceSessions = this._getEndToEndSessions(deviceKey) || {};\n            delete deviceSessions[sessionId];\n            if (Object.keys(deviceSessions).length === 0) {\n                // No more sessions for this device.\n                this.store.removeItem(keyEndToEndSessions(deviceKey));\n            } else {\n                setJsonItem(this.store, keyEndToEndSessions(deviceKey), deviceSessions);\n            }\n        }\n    }\n\n    // Inbound Group Sessions\n\n    public getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: unknown,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void {\n        func(\n            getJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId)),\n            getJsonItem(this.store, keyEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId)),\n        );\n    }\n\n    public storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void {\n        setJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId), sessionData);\n    }\n\n    /**\n     * Count the number of Megolm sessions in the database.\n     *\n     * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.\n     *\n     * @internal\n     */\n    public async countEndToEndInboundGroupSessions(): Promise<number> {\n        let count = 0;\n        for (let i = 0; i < this.store.length; ++i) {\n            const key = this.store.key(i);\n            if (key?.startsWith(KEY_INBOUND_SESSION_PREFIX)) {\n                count += 1;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Fetch a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndInboundGroupSessionsBatch(): Promise<SessionExtended[] | null> {\n        const sessionsNeedingBackup = getJsonItem<string[]>(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n        const result: SessionExtended[] = [];\n        for (let i = 0; i < this.store.length; ++i) {\n            const key = this.store.key(i);\n            if (key?.startsWith(KEY_INBOUND_SESSION_PREFIX)) {\n                const key2 = key.slice(KEY_INBOUND_SESSION_PREFIX.length);\n\n                // we can't use split, as the components we are trying to split out\n                // might themselves contain '/' characters. We rely on the\n                // senderKey being a (32-byte) curve25519 key, base64-encoded\n                // (hence 43 characters long).\n\n                result.push({\n                    senderKey: key2.slice(0, 43),\n                    sessionId: key2.slice(44),\n                    sessionData: getJsonItem(this.store, key)!,\n                    needsBackup: key2 in sessionsNeedingBackup,\n                });\n\n                if (result.length >= SESSION_BATCH_SIZE) {\n                    return result;\n                }\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndInboundGroupSessionsBatch(\n        sessions: { senderKey: string; sessionId: string }[],\n    ): Promise<void> {\n        for (const { senderKey, sessionId } of sessions) {\n            const k = keyEndToEndInboundGroupSession(senderKey, sessionId);\n            this.store.removeItem(k);\n        }\n    }\n\n    public getEndToEndRooms(txn: unknown, func: (rooms: Record<string, IRoomEncryption>) => void): void {\n        const result: Record<string, IRoomEncryption> = {};\n        const prefix = keyEndToEndRoomsPrefix(\"\");\n\n        for (let i = 0; i < this.store.length; ++i) {\n            const key = this.store.key(i);\n            if (key?.startsWith(prefix)) {\n                const roomId = key.slice(prefix.length);\n                result[roomId] = getJsonItem(this.store, key)!;\n            }\n        }\n        func(result);\n    }\n\n    public markSessionsNeedingBackup(sessions: ISession[]): Promise<void> {\n        const sessionsNeedingBackup =\n            getJsonItem<{\n                [senderKeySessionId: string]: boolean;\n            }>(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n        for (const session of sessions) {\n            sessionsNeedingBackup[session.senderKey + \"/\" + session.sessionId] = true;\n        }\n        setJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP, sessionsNeedingBackup);\n        return Promise.resolve();\n    }\n\n    /**\n     * Delete all data from this store.\n     *\n     * @returns Promise which resolves when the store has been cleared.\n     */\n    public deleteAllData(): Promise<void> {\n        this.store.removeItem(KEY_END_TO_END_ACCOUNT);\n        return Promise.resolve();\n    }\n\n    // Olm account\n\n    public getAccount(txn: unknown, func: (accountPickle: string | null) => void): void {\n        const accountPickle = getJsonItem<string>(this.store, KEY_END_TO_END_ACCOUNT);\n        func(accountPickle);\n    }\n\n    public storeAccount(txn: unknown, accountPickle: string): void {\n        setJsonItem(this.store, KEY_END_TO_END_ACCOUNT, accountPickle);\n    }\n\n    public getCrossSigningKeys(txn: unknown, func: (keys: Record<string, CrossSigningKeyInfo> | null) => void): void {\n        const keys = getJsonItem<Record<string, CrossSigningKeyInfo>>(this.store, KEY_CROSS_SIGNING_KEYS);\n        func(keys);\n    }\n\n    public getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void {\n        const key = getJsonItem<SecretStorePrivateKeys[K]>(this.store, E2E_PREFIX + `ssss_cache.${type}`);\n        func(key);\n    }\n\n    public storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void {\n        setJsonItem(this.store, E2E_PREFIX + `ssss_cache.${type}`, key);\n    }\n\n    public doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn: unknown) => T): Promise<T> {\n        return Promise.resolve(func(null));\n    }\n}\n\nfunction getJsonItem<T>(store: Storage, key: string): T | null {\n    try {\n        // if the key is absent, store.getItem() returns null, and\n        // JSON.parse(null) === null, so this returns null.\n        return JSON.parse(store.getItem(key)!);\n    } catch (e) {\n        logger.log(\"Error: Failed to get key %s: %s\", key, (<Error>e).message);\n        logger.log((<Error>e).stack);\n    }\n    return null;\n}\n\nfunction setJsonItem<T>(store: Storage, key: string, val: T): void {\n    store.setItem(key, JSON.stringify(val));\n}\n"],"mappings":"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","ignoreList":[]}