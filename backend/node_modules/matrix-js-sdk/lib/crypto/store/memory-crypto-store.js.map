{"version":3,"file":"memory-crypto-store.js","names":["safeSet","MigrationState","SESSION_BATCH_SIZE","encodeSessionKey","senderCurve25519Key","sessionId","encodeURIComponent","decodeSessionKey","key","keyParts","split","senderKey","decodeURIComponent","MemoryCryptoStore","constructor","_defineProperty","NOT_STARTED","containsData","_this","_asyncToGenerator","account","startup","_this2","deleteAllData","Promise","resolve","getMigrationState","_this3","migrationState","setMigrationState","_this4","getAccount","txn","func","storeAccount","accountPickle","getCrossSigningKeys","crossSigningKeys","getSecretStorePrivateKey","type","result","privateKeys","storeSecretStorePrivateKey","countEndToEndSessions","count","deviceSessions","Object","values","sessions","keys","length","getEndToEndSession","deviceKey","getEndToEndSessions","storeEndToEndSession","sessionInfo","undefined","getEndToEndSessionsBatch","_this5","session","push","deleteEndToEndSessionsBatch","_this6","getEndToEndInboundGroupSession","k","inboundGroupSessions","inboundGroupSessionsWithheld","storeEndToEndInboundGroupSession","sessionData","countEndToEndInboundGroupSessions","_this7","getEndToEndInboundGroupSessionsBatch","_this8","entries","_objectSpread","needsBackup","sessionsNeedingBackup","deleteEndToEndInboundGroupSessionsBatch","_this9","getEndToEndRooms","rooms","markSessionsNeedingBackup","sessionKey","doTxn","mode","stores"],"sources":["../../../src/crypto/store/memory-crypto-store.ts"],"sourcesContent":["/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { safeSet } from \"../../utils.ts\";\nimport {\n    type CryptoStore,\n    type ISession,\n    type SessionExtended,\n    type ISessionInfo,\n    type IWithheld,\n    MigrationState,\n    type Mode,\n    type SecretStorePrivateKeys,\n    SESSION_BATCH_SIZE,\n    type InboundGroupSessionData,\n    type IRoomEncryption,\n} from \"./base.ts\";\nimport { type CrossSigningKeyInfo } from \"../../crypto-api/index.ts\";\n\nfunction encodeSessionKey(senderCurve25519Key: string, sessionId: string): string {\n    return encodeURIComponent(senderCurve25519Key) + \"/\" + encodeURIComponent(sessionId);\n}\n\nfunction decodeSessionKey(key: string): { senderKey: string; sessionId: string } {\n    const keyParts = key.split(\"/\");\n    const senderKey = decodeURIComponent(keyParts[0]);\n    const sessionId = decodeURIComponent(keyParts[1]);\n    return { senderKey, sessionId };\n}\n\n/**\n * Internal module. in-memory storage for e2e.\n */\n\nexport class MemoryCryptoStore implements CryptoStore {\n    private migrationState: MigrationState = MigrationState.NOT_STARTED;\n    private account: string | null = null;\n    private crossSigningKeys: Record<string, CrossSigningKeyInfo> | null = null;\n    private privateKeys: Partial<SecretStorePrivateKeys> = {};\n\n    private sessions: { [deviceKey: string]: { [sessionId: string]: ISessionInfo } } = {};\n    private inboundGroupSessions: { [sessionKey: string]: InboundGroupSessionData } = {};\n    private inboundGroupSessionsWithheld: Record<string, IWithheld> = {};\n    // Opaque device data object\n    private rooms: { [roomId: string]: IRoomEncryption } = {};\n    private sessionsNeedingBackup: { [sessionKey: string]: boolean } = {};\n\n    /**\n     * Returns true if this CryptoStore has ever been initialised (ie, it might contain data).\n     *\n     * Implementation of {@link CryptoStore.containsData}.\n     *\n     * @internal\n     */\n    public async containsData(): Promise<boolean> {\n        // If it contains anything, it should contain an account.\n        return this.account !== null;\n    }\n\n    /**\n     * Ensure the database exists and is up-to-date.\n     *\n     * This must be called before the store can be used.\n     *\n     * @returns resolves to the store.\n     */\n    public async startup(): Promise<CryptoStore> {\n        // No startup work to do for the memory store.\n        return this;\n    }\n\n    /**\n     * Delete all data from this store.\n     *\n     * @returns Promise which resolves when the store has been cleared.\n     */\n    public deleteAllData(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Get data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.getMigrationState}.\n     *\n     * @internal\n     */\n    public async getMigrationState(): Promise<MigrationState> {\n        return this.migrationState;\n    }\n\n    /**\n     * Set data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.setMigrationState}.\n     *\n     * @internal\n     */\n    public async setMigrationState(migrationState: MigrationState): Promise<void> {\n        this.migrationState = migrationState;\n    }\n\n    // Olm Account\n\n    public getAccount(txn: unknown, func: (accountPickle: string | null) => void): void {\n        func(this.account);\n    }\n\n    public storeAccount(txn: unknown, accountPickle: string): void {\n        this.account = accountPickle;\n    }\n\n    public getCrossSigningKeys(txn: unknown, func: (keys: Record<string, CrossSigningKeyInfo> | null) => void): void {\n        func(this.crossSigningKeys);\n    }\n\n    public getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void {\n        const result = this.privateKeys[type] as SecretStorePrivateKeys[K] | undefined;\n        func(result || null);\n    }\n\n    public storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void {\n        this.privateKeys[type] = key;\n    }\n\n    // Olm Sessions\n\n    public countEndToEndSessions(txn: unknown, func: (count: number) => void): void {\n        let count = 0;\n        for (const deviceSessions of Object.values(this.sessions)) {\n            count += Object.keys(deviceSessions).length;\n        }\n        func(count);\n    }\n\n    public getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (session: ISessionInfo) => void,\n    ): void {\n        const deviceSessions = this.sessions[deviceKey] || {};\n        func(deviceSessions[sessionId] || null);\n    }\n\n    public getEndToEndSessions(\n        deviceKey: string,\n        txn: unknown,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void {\n        func(this.sessions[deviceKey] || {});\n    }\n\n    public storeEndToEndSession(deviceKey: string, sessionId: string, sessionInfo: ISessionInfo, txn: unknown): void {\n        let deviceSessions = this.sessions[deviceKey];\n        if (deviceSessions === undefined) {\n            deviceSessions = {};\n            this.sessions[deviceKey] = deviceSessions;\n        }\n        safeSet(deviceSessions, sessionId, sessionInfo);\n    }\n\n    /**\n     * Fetch a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndSessionsBatch(): Promise<null | ISessionInfo[]> {\n        const result: ISessionInfo[] = [];\n        for (const deviceSessions of Object.values(this.sessions)) {\n            for (const session of Object.values(deviceSessions)) {\n                result.push(session);\n                if (result.length >= SESSION_BATCH_SIZE) {\n                    return result;\n                }\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndSessionsBatch(sessions: { deviceKey: string; sessionId: string }[]): Promise<void> {\n        for (const { deviceKey, sessionId } of sessions) {\n            const deviceSessions = this.sessions[deviceKey] || {};\n            delete deviceSessions[sessionId];\n            if (Object.keys(deviceSessions).length === 0) {\n                // No more sessions for this device.\n                delete this.sessions[deviceKey];\n            }\n        }\n    }\n\n    // Inbound Group Sessions\n\n    public getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: unknown,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void {\n        const k = encodeSessionKey(senderCurve25519Key, sessionId);\n        func(this.inboundGroupSessions[k] || null, this.inboundGroupSessionsWithheld[k] || null);\n    }\n\n    public storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void {\n        const k = encodeSessionKey(senderCurve25519Key, sessionId);\n        this.inboundGroupSessions[k] = sessionData;\n    }\n\n    /**\n     * Count the number of Megolm sessions in the database.\n     *\n     * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.\n     *\n     * @internal\n     */\n    public async countEndToEndInboundGroupSessions(): Promise<number> {\n        return Object.keys(this.inboundGroupSessions).length;\n    }\n\n    /**\n     * Fetch a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndInboundGroupSessionsBatch(): Promise<null | SessionExtended[]> {\n        const result: SessionExtended[] = [];\n        for (const [key, session] of Object.entries(this.inboundGroupSessions)) {\n            result.push({\n                ...decodeSessionKey(key),\n                sessionData: session,\n                needsBackup: key in this.sessionsNeedingBackup,\n            });\n            if (result.length >= SESSION_BATCH_SIZE) {\n                return result;\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndInboundGroupSessionsBatch(\n        sessions: { senderKey: string; sessionId: string }[],\n    ): Promise<void> {\n        for (const { senderKey, sessionId } of sessions) {\n            const k = encodeSessionKey(senderKey, sessionId);\n            delete this.inboundGroupSessions[k];\n        }\n    }\n\n    // E2E rooms\n\n    public getEndToEndRooms(txn: unknown, func: (rooms: Record<string, IRoomEncryption>) => void): void {\n        func(this.rooms);\n    }\n\n    public markSessionsNeedingBackup(sessions: ISession[]): Promise<void> {\n        for (const session of sessions) {\n            const sessionKey = encodeSessionKey(session.senderKey, session.sessionId);\n            this.sessionsNeedingBackup[sessionKey] = true;\n        }\n        return Promise.resolve();\n    }\n\n    // Session key backups\n\n    public doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn?: unknown) => T): Promise<T> {\n        return Promise.resolve(func(null));\n    }\n}\n"],"mappings":"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","ignoreList":[]}