{"version":3,"file":"indexeddb-crypto-store-backend.js","names":["logger","MigrationState","SESSION_BATCH_SIZE","ACCOUNT_OBJECT_KEY_MIGRATION_STATE","IndexedDBCryptoStore","PROFILE_TRANSACTIONS","Backend","constructor","db","_defineProperty","onversionchange","log","concat","name","close","containsData","_asyncToGenerator","Error","startup","_this","deleteAllData","getMigrationState","_this2","migrationState","NOT_STARTED","doTxn","STORE_ACCOUNT","txn","objectStore","getReq","get","onsuccess","_getReq$result","result","setMigrationState","_this3","put","getAccount","func","e","abortWithException","storeAccount","accountPickle","getCrossSigningKeys","getSecretStorePrivateKey","type","storeSecretStorePrivateKey","key","countEndToEndSessions","countReq","count","getEndToEndSessions","deviceKey","idx","index","openCursor","results","cursor","value","sessionId","session","lastReceivedMessageTs","continue","getEndToEndSession","storeEndToEndSession","sessionInfo","getEndToEndSessionsBatch","_this4","STORE_SESSIONS","push","length","deleteEndToEndSessionsBatch","sessions","_this5","_ref","_loop","req","delete","Promise","resolve","_x","apply","arguments","getEndToEndInboundGroupSession","senderCurve25519Key","withheld","withheldObjectStore","withheldGetReq","storeEndToEndInboundGroupSession","sessionData","countEndToEndInboundGroupSessions","_this6","STORE_INBOUND_GROUP_SESSIONS","sessionStore","getEndToEndInboundGroupSessionsBatch","_this7","STORE_BACKUP","backupStore","backupGetReq","senderKey","needsBackup","undefined","deleteEndToEndInboundGroupSessionsBatch","_this8","_ref2","_loop2","_x2","getEndToEndDeviceData","getEndToEndRooms","rooms","markSessionsNeedingBackup","_this9","transaction","all","map","reject","onerror","mode","stores","startTime","description","txnId","nextTxnId","Date","now","debug","promise","promiseifyTxn","then","elapsedTime","error","DB_MIGRATIONS","createDatabase","createObjectStore","sessionsStore","keyPath","createIndex","problemsStore","VERSION","upgradeDatabase","oldVersion","forEach","migration","outgoingRoomKeyRequestsStore","_mx_abortexception","abort","_unused","oncomplete","event","onabort"],"sources":["../../../src/crypto/store/indexeddb-crypto-store-backend.ts"],"sourcesContent":["/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type Logger, logger } from \"../../logger.ts\";\nimport {\n    type CryptoStore,\n    type IDeviceData,\n    type ISession,\n    type SessionExtended,\n    type ISessionInfo,\n    type IWithheld,\n    MigrationState,\n    type Mode,\n    type SecretStorePrivateKeys,\n    SESSION_BATCH_SIZE,\n    ACCOUNT_OBJECT_KEY_MIGRATION_STATE,\n    type InboundGroupSessionData,\n    type IRoomEncryption,\n} from \"./base.ts\";\nimport { IndexedDBCryptoStore } from \"./indexeddb-crypto-store.ts\";\nimport { type CrossSigningKeyInfo } from \"../../crypto-api/index.ts\";\n\nconst PROFILE_TRANSACTIONS = false;\n\n/**\n * Implementation of a CryptoStore which is backed by an existing\n * IndexedDB connection. Generally you want IndexedDBCryptoStore\n * which connects to the database and defers to one of these.\n *\n * @internal\n */\nexport class Backend implements CryptoStore {\n    private nextTxnId = 0;\n\n    /**\n     */\n    public constructor(private db: IDBDatabase) {\n        // make sure we close the db on `onversionchange` - otherwise\n        // attempts to delete the database will block (and subsequent\n        // attempts to re-create it will also block).\n        db.onversionchange = (): void => {\n            logger.log(`versionchange for indexeddb ${this.db.name}: closing`);\n            db.close();\n        };\n    }\n\n    public async containsData(): Promise<boolean> {\n        throw Error(\"Not implemented for Backend\");\n    }\n\n    public async startup(): Promise<CryptoStore> {\n        // No work to do, as the startup is done by the caller (e.g IndexedDBCryptoStore)\n        // by passing us a ready IDBDatabase instance\n        return this;\n    }\n\n    public async deleteAllData(): Promise<void> {\n        throw Error(\"This is not implemented, call IDBFactory::deleteDatabase(dbName) instead.\");\n    }\n\n    /**\n     * Get data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.getMigrationState}.\n     */\n    public async getMigrationState(): Promise<MigrationState> {\n        let migrationState = MigrationState.NOT_STARTED;\n        await this.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\n            const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_ACCOUNT);\n            const getReq = objectStore.get(ACCOUNT_OBJECT_KEY_MIGRATION_STATE);\n            getReq.onsuccess = (): void => {\n                migrationState = getReq.result ?? MigrationState.NOT_STARTED;\n            };\n        });\n        return migrationState;\n    }\n\n    /**\n     * Set data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.setMigrationState}.\n     */\n    public async setMigrationState(migrationState: MigrationState): Promise<void> {\n        await this.doTxn(\"readwrite\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\n            const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_ACCOUNT);\n            objectStore.put(migrationState, ACCOUNT_OBJECT_KEY_MIGRATION_STATE);\n        });\n    }\n\n    // Olm Account\n\n    public getAccount(txn: IDBTransaction, func: (accountPickle: string | null) => void): void {\n        const objectStore = txn.objectStore(\"account\");\n        const getReq = objectStore.get(\"-\");\n        getReq.onsuccess = function (): void {\n            try {\n                func(getReq.result || null);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public storeAccount(txn: IDBTransaction, accountPickle: string): void {\n        const objectStore = txn.objectStore(\"account\");\n        objectStore.put(accountPickle, \"-\");\n    }\n\n    public getCrossSigningKeys(\n        txn: IDBTransaction,\n        func: (keys: Record<string, CrossSigningKeyInfo> | null) => void,\n    ): void {\n        const objectStore = txn.objectStore(\"account\");\n        const getReq = objectStore.get(\"crossSigningKeys\");\n        getReq.onsuccess = function (): void {\n            try {\n                func(getReq.result || null);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: IDBTransaction,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void {\n        const objectStore = txn.objectStore(\"account\");\n        const getReq = objectStore.get(`ssss_cache:${type}`);\n        getReq.onsuccess = function (): void {\n            try {\n                func(getReq.result || null);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: IDBTransaction,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void {\n        const objectStore = txn.objectStore(\"account\");\n        objectStore.put(key, `ssss_cache:${type}`);\n    }\n\n    // Olm Sessions\n\n    public countEndToEndSessions(txn: IDBTransaction, func: (count: number) => void): void {\n        const objectStore = txn.objectStore(\"sessions\");\n        const countReq = objectStore.count();\n        countReq.onsuccess = function (): void {\n            try {\n                func(countReq.result);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public getEndToEndSessions(\n        deviceKey: string,\n        txn: IDBTransaction,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void {\n        const objectStore = txn.objectStore(\"sessions\");\n        const idx = objectStore.index(\"deviceKey\");\n        const getReq = idx.openCursor(deviceKey);\n        const results: Parameters<Parameters<Backend[\"getEndToEndSessions\"]>[2]>[0] = {};\n        getReq.onsuccess = function (): void {\n            const cursor = getReq.result;\n            if (cursor) {\n                results[cursor.value.sessionId] = {\n                    session: cursor.value.session,\n                    lastReceivedMessageTs: cursor.value.lastReceivedMessageTs,\n                };\n                cursor.continue();\n            } else {\n                try {\n                    func(results);\n                } catch (e) {\n                    abortWithException(txn, <Error>e);\n                }\n            }\n        };\n    }\n\n    public getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: IDBTransaction,\n        func: (session: ISessionInfo | null) => void,\n    ): void {\n        const objectStore = txn.objectStore(\"sessions\");\n        const getReq = objectStore.get([deviceKey, sessionId]);\n        getReq.onsuccess = function (): void {\n            try {\n                if (getReq.result) {\n                    func({\n                        session: getReq.result.session,\n                        lastReceivedMessageTs: getReq.result.lastReceivedMessageTs,\n                    });\n                } else {\n                    func(null);\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public storeEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        sessionInfo: ISessionInfo,\n        txn: IDBTransaction,\n    ): void {\n        const objectStore = txn.objectStore(\"sessions\");\n        objectStore.put({\n            deviceKey,\n            sessionId,\n            session: sessionInfo.session,\n            lastReceivedMessageTs: sessionInfo.lastReceivedMessageTs,\n        });\n    }\n\n    /**\n     * Fetch a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.\n     */\n    public async getEndToEndSessionsBatch(): Promise<null | ISessionInfo[]> {\n        const result: ISessionInfo[] = [];\n        await this.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_SESSIONS], (txn) => {\n            const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_SESSIONS);\n            const getReq = objectStore.openCursor();\n            getReq.onsuccess = function (): void {\n                try {\n                    const cursor = getReq.result;\n                    if (cursor) {\n                        result.push(cursor.value);\n                        if (result.length < SESSION_BATCH_SIZE) {\n                            cursor.continue();\n                        }\n                    }\n                } catch (e) {\n                    abortWithException(txn, <Error>e);\n                }\n            };\n        });\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        return result;\n    }\n\n    /**\n     * Delete a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndSessionsBatch(sessions: { deviceKey: string; sessionId: string }[]): Promise<void> {\n        await this.doTxn(\"readwrite\", [IndexedDBCryptoStore.STORE_SESSIONS], async (txn) => {\n            try {\n                const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_SESSIONS);\n                for (const { deviceKey, sessionId } of sessions) {\n                    const req = objectStore.delete([deviceKey, sessionId]);\n                    await new Promise((resolve) => {\n                        req.onsuccess = resolve;\n                    });\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        });\n    }\n\n    // Inbound group sessions\n\n    public getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: IDBTransaction,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void {\n        let session: InboundGroupSessionData | null | boolean = false;\n        let withheld: IWithheld | null | boolean = false;\n        const objectStore = txn.objectStore(\"inbound_group_sessions\");\n        const getReq = objectStore.get([senderCurve25519Key, sessionId]);\n        getReq.onsuccess = function (): void {\n            try {\n                if (getReq.result) {\n                    session = getReq.result.session;\n                } else {\n                    session = null;\n                }\n                if (withheld !== false) {\n                    func(session as InboundGroupSessionData, withheld as IWithheld);\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n\n        const withheldObjectStore = txn.objectStore(\"inbound_group_sessions_withheld\");\n        const withheldGetReq = withheldObjectStore.get([senderCurve25519Key, sessionId]);\n        withheldGetReq.onsuccess = function (): void {\n            try {\n                if (withheldGetReq.result) {\n                    withheld = withheldGetReq.result.session;\n                } else {\n                    withheld = null;\n                }\n                if (session !== false) {\n                    func(session as InboundGroupSessionData, withheld as IWithheld);\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: IDBTransaction,\n    ): void {\n        const objectStore = txn.objectStore(\"inbound_group_sessions\");\n        objectStore.put({\n            senderCurve25519Key,\n            sessionId,\n            session: sessionData,\n        });\n    }\n\n    /**\n     * Count the number of Megolm sessions in the database.\n     *\n     * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.\n     *\n     * @internal\n     */\n    public async countEndToEndInboundGroupSessions(): Promise<number> {\n        let result = 0;\n        await this.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], (txn) => {\n            const sessionStore = txn.objectStore(IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS);\n            const countReq = sessionStore.count();\n            countReq.onsuccess = (): void => {\n                result = countReq.result;\n            };\n        });\n        return result;\n    }\n\n    /**\n     * Fetch a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.\n     */\n    public async getEndToEndInboundGroupSessionsBatch(): Promise<null | SessionExtended[]> {\n        const result: SessionExtended[] = [];\n        await this.doTxn(\n            \"readonly\",\n            [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, IndexedDBCryptoStore.STORE_BACKUP],\n            (txn) => {\n                const sessionStore = txn.objectStore(IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS);\n                const backupStore = txn.objectStore(IndexedDBCryptoStore.STORE_BACKUP);\n\n                const getReq = sessionStore.openCursor();\n                getReq.onsuccess = function (): void {\n                    try {\n                        const cursor = getReq.result;\n                        if (cursor) {\n                            const backupGetReq = backupStore.get(cursor.key);\n                            backupGetReq.onsuccess = (): void => {\n                                result.push({\n                                    senderKey: cursor.value.senderCurve25519Key,\n                                    sessionId: cursor.value.sessionId,\n                                    sessionData: cursor.value.session,\n                                    needsBackup: backupGetReq.result !== undefined,\n                                });\n                                if (result.length < SESSION_BATCH_SIZE) {\n                                    cursor.continue();\n                                }\n                            };\n                        }\n                    } catch (e) {\n                        abortWithException(txn, <Error>e);\n                    }\n                };\n            },\n        );\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        return result;\n    }\n\n    /**\n     * Delete a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndInboundGroupSessionsBatch(\n        sessions: { senderKey: string; sessionId: string }[],\n    ): Promise<void> {\n        await this.doTxn(\"readwrite\", [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], async (txn) => {\n            try {\n                const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS);\n                for (const { senderKey, sessionId } of sessions) {\n                    const req = objectStore.delete([senderKey, sessionId]);\n                    await new Promise((resolve) => {\n                        req.onsuccess = resolve;\n                    });\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        });\n    }\n\n    public getEndToEndDeviceData(txn: IDBTransaction, func: (deviceData: IDeviceData | null) => void): void {\n        const objectStore = txn.objectStore(\"device_data\");\n        const getReq = objectStore.get(\"-\");\n        getReq.onsuccess = function (): void {\n            try {\n                func(getReq.result || null);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public getEndToEndRooms(txn: IDBTransaction, func: (rooms: Record<string, IRoomEncryption>) => void): void {\n        const rooms: Parameters<Parameters<Backend[\"getEndToEndRooms\"]>[1]>[0] = {};\n        const objectStore = txn.objectStore(\"rooms\");\n        const getReq = objectStore.openCursor();\n        getReq.onsuccess = function (): void {\n            const cursor = getReq.result;\n            if (cursor) {\n                rooms[cursor.key as string] = cursor.value;\n                cursor.continue();\n            } else {\n                try {\n                    func(rooms);\n                } catch (e) {\n                    abortWithException(txn, <Error>e);\n                }\n            }\n        };\n    }\n\n    public async markSessionsNeedingBackup(sessions: ISession[], txn?: IDBTransaction): Promise<void> {\n        if (!txn) {\n            txn = this.db.transaction(\"sessions_needing_backup\", \"readwrite\");\n        }\n        const objectStore = txn.objectStore(\"sessions_needing_backup\");\n        await Promise.all(\n            sessions.map((session) => {\n                return new Promise((resolve, reject) => {\n                    const req = objectStore.put({\n                        senderCurve25519Key: session.senderKey,\n                        sessionId: session.sessionId,\n                    });\n                    req.onsuccess = resolve;\n                    req.onerror = reject;\n                });\n            }),\n        );\n    }\n\n    public doTxn<T>(\n        mode: Mode,\n        stores: string | string[],\n        func: (txn: IDBTransaction) => T,\n        log: Logger = logger,\n    ): Promise<T> {\n        let startTime: number;\n        let description: string;\n        if (PROFILE_TRANSACTIONS) {\n            const txnId = this.nextTxnId++;\n            startTime = Date.now();\n            description = `${mode} crypto store transaction ${txnId} in ${stores}`;\n            log.debug(`Starting ${description}`);\n        }\n        const txn = this.db.transaction(stores, mode);\n        const promise = promiseifyTxn(txn);\n        const result = func(txn);\n        if (PROFILE_TRANSACTIONS) {\n            promise.then(\n                () => {\n                    const elapsedTime = Date.now() - startTime;\n                    log.debug(`Finished ${description}, took ${elapsedTime} ms`);\n                },\n                () => {\n                    const elapsedTime = Date.now() - startTime;\n                    log.error(`Failed ${description}, took ${elapsedTime} ms`);\n                },\n            );\n        }\n        return promise.then(() => {\n            return result;\n        });\n    }\n}\n\ntype DbMigration = (db: IDBDatabase) => void;\nconst DB_MIGRATIONS: DbMigration[] = [\n    (db): void => {\n        createDatabase(db);\n    },\n    (db): void => {\n        db.createObjectStore(\"account\");\n    },\n    (db): void => {\n        const sessionsStore = db.createObjectStore(\"sessions\", {\n            keyPath: [\"deviceKey\", \"sessionId\"],\n        });\n        sessionsStore.createIndex(\"deviceKey\", \"deviceKey\");\n    },\n    (db): void => {\n        db.createObjectStore(\"inbound_group_sessions\", {\n            keyPath: [\"senderCurve25519Key\", \"sessionId\"],\n        });\n    },\n    (db): void => {\n        db.createObjectStore(\"device_data\");\n    },\n    (db): void => {\n        db.createObjectStore(\"rooms\");\n    },\n    (db): void => {\n        db.createObjectStore(\"sessions_needing_backup\", {\n            keyPath: [\"senderCurve25519Key\", \"sessionId\"],\n        });\n    },\n    (db): void => {\n        db.createObjectStore(\"inbound_group_sessions_withheld\", {\n            keyPath: [\"senderCurve25519Key\", \"sessionId\"],\n        });\n    },\n    (db): void => {\n        const problemsStore = db.createObjectStore(\"session_problems\", {\n            keyPath: [\"deviceKey\", \"time\"],\n        });\n        problemsStore.createIndex(\"deviceKey\", \"deviceKey\");\n\n        db.createObjectStore(\"notified_error_devices\", {\n            keyPath: [\"userId\", \"deviceId\"],\n        });\n    },\n    (db): void => {\n        db.createObjectStore(\"shared_history_inbound_group_sessions\", {\n            keyPath: [\"roomId\"],\n        });\n    },\n    (db): void => {\n        db.createObjectStore(\"parked_shared_history\", {\n            keyPath: [\"roomId\"],\n        });\n    },\n    // Expand as needed.\n];\nexport const VERSION = DB_MIGRATIONS.length;\n\nexport function upgradeDatabase(db: IDBDatabase, oldVersion: number): void {\n    logger.log(`Upgrading IndexedDBCryptoStore from version ${oldVersion}` + ` to ${VERSION}`);\n    DB_MIGRATIONS.forEach((migration, index) => {\n        if (oldVersion <= index) migration(db);\n    });\n}\n\nfunction createDatabase(db: IDBDatabase): void {\n    const outgoingRoomKeyRequestsStore = db.createObjectStore(\"outgoingRoomKeyRequests\", { keyPath: \"requestId\" });\n\n    // we assume that the RoomKeyRequestBody will have room_id and session_id\n    // properties, to make the index efficient.\n    outgoingRoomKeyRequestsStore.createIndex(\"session\", [\"requestBody.room_id\", \"requestBody.session_id\"]);\n\n    outgoingRoomKeyRequestsStore.createIndex(\"state\", \"state\");\n}\n\ninterface IWrappedIDBTransaction extends IDBTransaction {\n    _mx_abortexception: Error; // eslint-disable-line camelcase\n}\n\n/*\n * Aborts a transaction with a given exception\n * The transaction promise will be rejected with this exception.\n */\nfunction abortWithException(txn: IDBTransaction, e: Error): void {\n    // We cheekily stick our exception onto the transaction object here\n    // We could alternatively make the thing we pass back to the app\n    // an object containing the transaction and exception.\n    (txn as IWrappedIDBTransaction)._mx_abortexception = e;\n    try {\n        txn.abort();\n    } catch {\n        // sometimes we won't be able to abort the transaction\n        // (ie. if it's aborted or completed)\n    }\n}\n\nfunction promiseifyTxn<T>(txn: IDBTransaction): Promise<T | null> {\n    return new Promise((resolve, reject) => {\n        txn.oncomplete = (): void => {\n            if ((txn as IWrappedIDBTransaction)._mx_abortexception !== undefined) {\n                reject((txn as IWrappedIDBTransaction)._mx_abortexception);\n            }\n            resolve(null);\n        };\n        txn.onerror = (event): void => {\n            if ((txn as IWrappedIDBTransaction)._mx_abortexception !== undefined) {\n                reject((txn as IWrappedIDBTransaction)._mx_abortexception);\n            } else {\n                logger.log(\"Error performing indexeddb txn\", event);\n                reject(txn.error);\n            }\n        };\n        txn.onabort = (event): void => {\n            if ((txn as IWrappedIDBTransaction)._mx_abortexception !== undefined) {\n                reject((txn as IWrappedIDBTransaction)._mx_abortexception);\n            } else {\n                logger.log(\"Error performing indexeddb txn\", event);\n                reject(txn.error);\n            }\n        };\n    });\n}\n"],"mappings":"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","ignoreList":[]}