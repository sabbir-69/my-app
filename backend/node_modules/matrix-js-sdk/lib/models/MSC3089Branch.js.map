{"version":3,"file":"MSC3089Branch.js","names":["RelationType","UNSTABLE_MSC3089_BRANCH","EventTimeline","MSC3089Branch","constructor","client","indexEvent","directory","id","stateKey","getStateKey","Error","isActive","getContent","version","_this$indexEvent$getC","roomId","getRoomId","delete","_this","_asyncToGenerator","sendStateEvent","name","redactEvent","nextVersion","getVersionHistory","getName","setName","_this2","_objectSpread","isLocked","setLocked","locked","_this3","getFileInfo","_this4","event","getFileEvent","file","getOriginalContent","httpUrl","mxcUrlToHttp","concat","info","_this5","room","getRoom","getUnfilteredTimelineSet","findEventById","getLiveTimeline","getState","BACKWARDS","paginationToken","scrollback","decryptEventIfNeeded","createNewVersion","encryptedContents","additionalContent","_this6","fileEventResponse","createFile","rel_type","Replace","event_id","active","_this7","fileHistory","push","timelineEvents","getEvents","reverse","childEvent","parentEvent","find","e","replacingEventId","getId","branch","getFile"],"sources":["../../src/models/MSC3089Branch.ts"],"sourcesContent":["/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixClient } from \"../client.ts\";\nimport { RelationType, UNSTABLE_MSC3089_BRANCH } from \"../@types/event.ts\";\nimport { type IContent, type MatrixEvent } from \"./event.ts\";\nimport { type MSC3089TreeSpace } from \"./MSC3089TreeSpace.ts\";\nimport { EventTimeline } from \"./event-timeline.ts\";\nimport { type FileType } from \"../http-api/index.ts\";\nimport type { ISendEventResponse } from \"../@types/requests.ts\";\nimport { type EncryptedFile } from \"../@types/media.ts\";\n\nexport interface MSC3089EventContent {\n    active?: boolean;\n    name?: string;\n    locked?: boolean;\n    version?: number;\n}\n\nexport interface MSC3089EventContent {\n    active?: boolean;\n    name?: string;\n    locked?: boolean;\n    version?: number;\n}\n\n/**\n * Represents a [MSC3089](https://github.com/matrix-org/matrix-doc/pull/3089) branch - a reference\n * to a file (leaf) in the tree. Note that this is UNSTABLE and subject to breaking changes\n * without notice.\n */\nexport class MSC3089Branch {\n    public constructor(\n        private client: MatrixClient,\n        public readonly indexEvent: MatrixEvent,\n        public readonly directory: MSC3089TreeSpace,\n    ) {\n        // Nothing to do\n    }\n\n    /**\n     * The file ID.\n     */\n    public get id(): string {\n        const stateKey = this.indexEvent.getStateKey();\n        if (!stateKey) {\n            throw new Error(\"State key not found for branch\");\n        }\n        return stateKey;\n    }\n\n    /**\n     * Whether this branch is active/valid.\n     */\n    public get isActive(): boolean {\n        return this.indexEvent.getContent()[\"active\"] === true;\n    }\n\n    /**\n     * Version for the file, one-indexed.\n     */\n    public get version(): number {\n        return this.indexEvent.getContent()[\"version\"] ?? 1;\n    }\n\n    private get roomId(): string {\n        return this.indexEvent.getRoomId()!;\n    }\n\n    /**\n     * Deletes the file from the tree, including all prior edits/versions.\n     * @returns Promise which resolves when complete.\n     */\n    public async delete(): Promise<void> {\n        await this.client.sendStateEvent(this.roomId, UNSTABLE_MSC3089_BRANCH.name, {}, this.id);\n        await this.client.redactEvent(this.roomId, this.id);\n\n        const nextVersion = (await this.getVersionHistory())[1]; // [0] will be us\n        if (nextVersion) await nextVersion.delete(); // implicit recursion\n    }\n\n    /**\n     * Gets the name for this file.\n     * @returns The name, or \"Unnamed File\" if unknown.\n     */\n    public getName(): string {\n        return this.indexEvent.getContent()[\"name\"] || \"Unnamed File\";\n    }\n\n    /**\n     * Sets the name for this file.\n     * @param name - The new name for this file.\n     * @returns Promise which resolves when complete.\n     */\n    public async setName(name: string): Promise<void> {\n        await this.client.sendStateEvent(\n            this.roomId,\n            UNSTABLE_MSC3089_BRANCH.name,\n            {\n                ...this.indexEvent.getContent(),\n                name: name,\n            },\n            this.id,\n        );\n    }\n\n    /**\n     * Gets whether or not a file is locked.\n     * @returns True if locked, false otherwise.\n     */\n    public isLocked(): boolean {\n        return this.indexEvent.getContent()[\"locked\"] || false;\n    }\n\n    /**\n     * Sets a file as locked or unlocked.\n     * @param locked - True to lock the file, false otherwise.\n     * @returns Promise which resolves when complete.\n     */\n    public async setLocked(locked: boolean): Promise<void> {\n        await this.client.sendStateEvent(\n            this.roomId,\n            UNSTABLE_MSC3089_BRANCH.name,\n            {\n                ...this.indexEvent.getContent(),\n                locked: locked,\n            },\n            this.id,\n        );\n    }\n\n    /**\n     * Gets information about the file needed to download it.\n     * @returns Information about the file.\n     */\n    public async getFileInfo(): Promise<{ info: EncryptedFile; httpUrl: string }> {\n        const event = await this.getFileEvent();\n\n        const file = event.getOriginalContent()[\"file\"];\n        const httpUrl = this.client.mxcUrlToHttp(file[\"url\"]);\n\n        if (!httpUrl) {\n            throw new Error(`No HTTP URL available for ${file[\"url\"]}`);\n        }\n\n        return { info: file, httpUrl: httpUrl };\n    }\n\n    /**\n     * Gets the event the file points to.\n     * @returns Promise which resolves to the file's event.\n     */\n    public async getFileEvent(): Promise<MatrixEvent> {\n        const room = this.client.getRoom(this.roomId);\n        if (!room) throw new Error(\"Unknown room\");\n\n        let event: MatrixEvent | undefined = room.getUnfilteredTimelineSet().findEventById(this.id);\n\n        // keep scrolling back if needed until we find the event or reach the start of the room:\n        while (!event && room.getLiveTimeline().getState(EventTimeline.BACKWARDS)!.paginationToken) {\n            await this.client.scrollback(room, 100);\n            event = room.getUnfilteredTimelineSet().findEventById(this.id);\n        }\n\n        if (!event) throw new Error(\"Failed to find event\");\n\n        // Sometimes the event isn't decrypted for us, so do that.\n        await this.client.decryptEventIfNeeded(event);\n\n        return event;\n    }\n\n    /**\n     * Creates a new version of this file with contents in a type that is compatible with MatrixClient.uploadContent().\n     * @param name - The name of the file.\n     * @param encryptedContents - The encrypted contents.\n     * @param info - The encrypted file information.\n     * @param additionalContent - Optional event content fields to include in the message.\n     * @returns Promise which resolves to the file event's sent response.\n     */\n    public async createNewVersion(\n        name: string,\n        encryptedContents: FileType,\n        info: EncryptedFile,\n        additionalContent?: IContent,\n    ): Promise<ISendEventResponse> {\n        const fileEventResponse = await this.directory.createFile(name, encryptedContents, info, {\n            ...(additionalContent ?? {}),\n            \"m.new_content\": true,\n            \"m.relates_to\": {\n                rel_type: RelationType.Replace,\n                event_id: this.id,\n            },\n        });\n\n        // Update the version of the new event\n        await this.client.sendStateEvent(\n            this.roomId,\n            UNSTABLE_MSC3089_BRANCH.name,\n            {\n                active: true,\n                name: name,\n                version: this.version + 1,\n            },\n            fileEventResponse[\"event_id\"],\n        );\n\n        // Deprecate ourselves\n        await this.client.sendStateEvent(\n            this.roomId,\n            UNSTABLE_MSC3089_BRANCH.name,\n            {\n                ...this.indexEvent.getContent(),\n                active: false,\n            },\n            this.id,\n        );\n\n        return fileEventResponse;\n    }\n\n    /**\n     * Gets the file's version history, starting at this file.\n     * @returns Promise which resolves to the file's version history, with the\n     * first element being the current version and the last element being the first version.\n     */\n    public async getVersionHistory(): Promise<MSC3089Branch[]> {\n        const fileHistory: MSC3089Branch[] = [];\n        fileHistory.push(this); // start with ourselves\n\n        const room = this.client.getRoom(this.roomId);\n        if (!room) throw new Error(\"Invalid or unknown room\");\n\n        // Clone the timeline to reverse it, getting most-recent-first ordering, hopefully\n        // shortening the awful loop below. Without the clone, we can unintentionally mutate\n        // the timeline.\n        const timelineEvents = [...room.getLiveTimeline().getEvents()].reverse();\n\n        // XXX: This is a very inefficient search, but it's the best we can do with the\n        // relations structure we have in the SDK. As of writing, it is not worth the\n        // investment in improving the structure.\n        let childEvent: MatrixEvent | undefined;\n        let parentEvent = await this.getFileEvent();\n        do {\n            childEvent = timelineEvents.find((e) => e.replacingEventId() === parentEvent.getId());\n            if (childEvent) {\n                const branch = this.directory.getFile(childEvent.getId()!);\n                if (branch) {\n                    fileHistory.push(branch);\n                    parentEvent = childEvent;\n                } else {\n                    break; // prevent infinite loop\n                }\n            }\n        } while (childEvent);\n\n        return fileHistory;\n    }\n}\n"],"mappings":"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","ignoreList":[]}