{"version":3,"file":"refresh.js","names":["MatrixError","TokenRefreshLogoutError","sleep","TokenRefreshOutcome","REFRESH_IF_TOKEN_EXPIRES_WITHIN_MS","REFRESH_ON_ERROR_IF_TOKEN_EXPIRES_WITHIN_MS","TokenRefresher","constructor","opts","_defineProperty","prepareForRequest","_this","_asyncToGenerator","refreshIfNeeded","accessToken","refreshToken","expiry","latestTokenRefreshExpiry","_this2","tokenRefreshPromise","expiresIn","getTime","Date","now","_handleUnknownToken","handleUnknownToken","snapshot","attempt","_this3","_this4","Logout","_this4$tokenRefreshPr","doTokenRefresh","undefined","Success","_this5","tokenRefreshFunction","_this5$opts$logger","logger","error","Math","min","_this5$opts$logger2","_this5$opts$logger3","debug","_this5$opts$logger5","_this5$opts$logger4","warn","Failure"],"sources":["../../src/http-api/refresh.ts"],"sourcesContent":["/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MatrixError, TokenRefreshLogoutError } from \"./errors.ts\";\nimport { type IHttpOpts } from \"./interface.ts\";\nimport { sleep } from \"../utils.ts\";\n\n/**\n * This is an internal module. See {@link MatrixHttpApi} for the public class.\n */\n\nexport const enum TokenRefreshOutcome {\n    Success = \"success\",\n    Failure = \"failure\",\n    Logout = \"logout\",\n}\n\ninterface Snapshot {\n    accessToken: string;\n    refreshToken?: string;\n    expiry?: Date;\n}\n\n// If the token expires in less than this time amount of time, we will eagerly refresh it before making the intended request.\nconst REFRESH_IF_TOKEN_EXPIRES_WITHIN_MS = 500;\n// If we get an unknown token error and the token expires in less than this time amount of time, we will refresh it before making the intended request.\n// Otherwise, we will error as the token should not have expired yet and we need to avoid retrying indefinitely.\nconst REFRESH_ON_ERROR_IF_TOKEN_EXPIRES_WITHIN_MS = 60 * 1000;\n\ntype Opts = Pick<IHttpOpts, \"tokenRefreshFunction\" | \"logger\" | \"refreshToken\" | \"accessToken\">;\n\n/**\n * This class is responsible for managing the access token and refresh token for authenticated requests.\n * It will automatically refresh the access token when it is about to expire, and will handle unknown token errors.\n */\nexport class TokenRefresher {\n    public constructor(private readonly opts: Opts) {}\n\n    /**\n     * Promise used to block authenticated requests during a token refresh to avoid repeated expected errors.\n     * @private\n     */\n    private tokenRefreshPromise?: Promise<TokenRefreshOutcome>;\n\n    private latestTokenRefreshExpiry?: Date;\n\n    /**\n     * This function is called before every request to ensure that the access token is valid.\n     * @returns a snapshot containing the access token and other properties which must be passed to the handleUnknownToken\n     *     handler if an M_UNKNOWN_TOKEN error is encountered.\n     */\n    public async prepareForRequest(): Promise<Snapshot> {\n        // Ensure our token is refreshed before we build the headers/params\n        await this.refreshIfNeeded();\n\n        return {\n            accessToken: this.opts.accessToken!,\n            refreshToken: this.opts.refreshToken,\n            expiry: this.latestTokenRefreshExpiry,\n        };\n    }\n\n    private async refreshIfNeeded(): Promise<unknown> {\n        if (this.tokenRefreshPromise) {\n            return this.tokenRefreshPromise;\n        }\n        // If we don't know the token expiry, we can't eagerly refresh\n        if (!this.latestTokenRefreshExpiry) return;\n\n        const expiresIn = this.latestTokenRefreshExpiry.getTime() - Date.now();\n        if (expiresIn <= REFRESH_IF_TOKEN_EXPIRES_WITHIN_MS) {\n            await this._handleUnknownToken();\n        }\n    }\n\n    /**\n     * This function is called when an M_UNKNOWN_TOKEN error is encountered.\n     * It will attempt to refresh the access token if it is unknown, and will return a TokenRefreshOutcome.\n     * @param snapshot - the snapshot returned by prepareForRequest\n     * @param attempt - the number of attempts made for this request so far\n     * @returns a TokenRefreshOutcome indicating the result of the refresh attempt\n     */\n    public async handleUnknownToken(snapshot: Snapshot, attempt: number): Promise<TokenRefreshOutcome> {\n        return this._handleUnknownToken(snapshot, attempt);\n    }\n\n    /* eslint-disable @typescript-eslint/naming-convention */\n    private async _handleUnknownToken(): Promise<TokenRefreshOutcome>;\n    private async _handleUnknownToken(snapshot: Snapshot, attempt: number): Promise<TokenRefreshOutcome>;\n    private async _handleUnknownToken(snapshot?: Snapshot, attempt?: number): Promise<TokenRefreshOutcome> {\n        if (snapshot?.expiry) {\n            // If our token is unknown, but it should not have expired yet, then we should not refresh\n            const expiresIn = snapshot.expiry.getTime() - Date.now();\n            // If it still has plenty of time left on the clock, we assume something else must be wrong and\n            // do not refresh. Otherwise if it's expired, or will soon, we try refreshing.\n            if (expiresIn >= REFRESH_ON_ERROR_IF_TOKEN_EXPIRES_WITHIN_MS) {\n                return TokenRefreshOutcome.Logout;\n            }\n        }\n\n        if (!snapshot || snapshot?.accessToken === this.opts.accessToken) {\n            // If we have a snapshot, but the access token is the same as the current one then a refresh\n            // did not happen behind us but one may be ongoing anyway\n            this.tokenRefreshPromise ??= this.doTokenRefresh(attempt);\n\n            try {\n                return await this.tokenRefreshPromise;\n            } finally {\n                this.tokenRefreshPromise = undefined;\n            }\n        }\n\n        // We may end up here if the token was refreshed in the background due to another request\n        return TokenRefreshOutcome.Success;\n    }\n\n    /**\n     * Attempt to refresh access tokens.\n     * On success, sets new access and refresh tokens in opts.\n     * @returns Promise that resolves to a boolean - true when token was refreshed successfully\n     */\n    private async doTokenRefresh(attempt?: number): Promise<TokenRefreshOutcome> {\n        if (!this.opts.refreshToken || !this.opts.tokenRefreshFunction) {\n            this.opts.logger?.error(\"Unable to refresh token - no refresh token or refresh function\");\n            return TokenRefreshOutcome.Logout;\n        }\n\n        if (attempt && attempt > 1) {\n            // Exponential backoff to ensure we don't trash the server, up to 2^5 seconds\n            await sleep(1000 * Math.min(32, 2 ** attempt));\n        }\n\n        try {\n            this.opts.logger?.debug(\"Attempting to refresh token\");\n            const { accessToken, refreshToken, expiry } = await this.opts.tokenRefreshFunction(this.opts.refreshToken);\n            this.opts.accessToken = accessToken;\n            this.opts.refreshToken = refreshToken;\n            this.latestTokenRefreshExpiry = expiry;\n            this.opts.logger?.debug(\"... token refresh complete, new token expiry:\", expiry);\n\n            // successfully got new tokens\n            return TokenRefreshOutcome.Success;\n        } catch (error) {\n            // If we get a TokenError or MatrixError, we should log out, otherwise assume transient\n            if (error instanceof TokenRefreshLogoutError || error instanceof MatrixError) {\n                this.opts.logger?.error(\"Failed to refresh token\", error);\n                return TokenRefreshOutcome.Logout;\n            }\n\n            this.opts.logger?.warn(\"Failed to refresh token\", error);\n            return TokenRefreshOutcome.Failure;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]}