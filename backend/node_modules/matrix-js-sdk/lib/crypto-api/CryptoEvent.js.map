{"version":3,"file":"CryptoEvent.js","names":["CryptoEvent"],"sources":["../../src/crypto-api/CryptoEvent.ts"],"sourcesContent":["/*\n * Copyright 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Cryptography-related events emitted by the {@link matrix.MatrixClient}.\n */\nexport enum CryptoEvent {\n    /**\n     * Fires when the trust status of a user changes.\n     * The payload is a pair (userId, userTrustLevel). The trust level is one of the values from UserVerificationStatus.\n     */\n    UserTrustStatusChanged = \"userTrustStatusChanged\",\n\n    /**\n     * Fires when the key backup status changes.\n     * The payload is a boolean indicating whether the key backup is enabled.\n     */\n    KeyBackupStatus = \"crypto.keyBackupStatus\",\n\n    /**\n     * Fires when we failed to back up the keys\n     * The payload is the error code of the error that occurred.\n     */\n    KeyBackupFailed = \"crypto.keyBackupFailed\",\n\n    /**\n     * Fires when the number of sessions that can be backed up changes.\n     * The payload is the remaining number of sessions that can be backed up.\n     */\n    KeyBackupSessionsRemaining = \"crypto.keyBackupSessionsRemaining\",\n\n    /**\n     * Fires when a new valid backup decryption key is in cache.\n     * This will happen when a secret is received from another session, from secret storage,\n     * or when a new backup is created from this session.\n     *\n     * The payload is the version of the backup for which we have the key for.\n     *\n     * This event is only fired by the rust crypto backend.\n     */\n    KeyBackupDecryptionKeyCached = \"crypto.keyBackupDecryptionKeyCached\",\n\n    /**\n     * Fires when a key verification request is received.\n     * The payload is a VerificationRequest object representing the request.\n     */\n    VerificationRequestReceived = \"crypto.verificationRequestReceived\",\n\n    /** @deprecated Use {@link DevicesUpdated} instead when using rust crypto */\n    WillUpdateDevices = \"crypto.willUpdateDevices\",\n\n    /**\n     * Fires whenever the stored devices for a user have been updated\n     * The payload is a pair (userIds, initialFetch).\n     */\n    DevicesUpdated = \"crypto.devicesUpdated\",\n\n    /**\n     * Fires when the user's cross-signing keys have changed or cross-signing\n     * has been enabled/disabled. The client can use getStoredCrossSigningForUser\n     * with the user ID of the logged in user to check if cross-signing is\n     * enabled on the account. If enabled, it can test whether the current key\n     * is trusted using with checkUserTrust with the user ID of the logged\n     * in user. The checkOwnCrossSigningTrust function may be used to reconcile\n     * the trust in the account key.\n     *\n     * The cross-signing API is currently UNSTABLE and may change without notice.\n     * @experimental\n     */\n    KeysChanged = \"crossSigning.keysChanged\",\n\n    /**\n     * Fires when data is being migrated from legacy crypto to rust crypto.\n     *\n     * The payload is a pair `(progress, total)`, where `progress` is the number of steps completed so far, and\n     * `total` is the total number of steps. When migration is complete, a final instance of the event is emitted, with\n     * `progress === total === -1`.\n     */\n    LegacyCryptoStoreMigrationProgress = \"crypto.legacyCryptoStoreMigrationProgress\",\n\n    /**\n     * Fires when a new dehydrated device is created locally.\n     *\n     * After the client calls {@link CryptoApi.startDehydration}, this event\n     * will be fired every time a new dehydrated device is created.  It may fire\n     * before `startDehydration` returns.\n     */\n    DehydratedDeviceCreated = \"dehydration.DehydratedDeviceCreated\",\n\n    /**\n     * Fires when a new dehydrated device is successfully uploaded to the server.\n     *\n     * This should fire shortly after {@link DehydratedDeviceCreated} fires. If\n     * upload is unsuccessful, this will be reported either by an error thrown\n     * by {@link CryptoApi.startDehydration} (for errors that happen before\n     * `startDehydration` returns), or by firing {@link DehydratedDeviceRotationError}\n     * (for errors that happen during regular rotation of the dehydrated device)\n     */\n    DehydratedDeviceUploaded = \"dehydration.DehydratedDeviceUploaded\",\n\n    /**\n     * Fires when rehydration has started.\n     *\n     * After the client calls {@link CryptoApi.startDehydration}, this event will\n     * fire if a dehydrated device is found and we attempt to rehydrate it.\n     */\n    RehydrationStarted = \"dehydration.RehydrationStarted\",\n\n    /**\n     * Fires during rehydration, to inform the application of rehydration progress.\n     *\n     * The payload is a pair `[roomKeyCount: number, toDeviceCount: number]`,\n     * where `roomKeyCount` is the number of room keys that have been received\n     * so far, and `toDeviceCount` is the number of to-device messages received\n     * so far (including the messages containing room keys).\n     */\n    RehydrationProgress = \"dehydration.RehydrationProgress\",\n\n    /** Fires when rehydration has completed successfully. */\n    RehydrationCompleted = \"dehydration.RehydrationCompleted\",\n\n    /** Fires when there was an error in rehydration.\n     *\n     * The payload is an error message as a string.\n     */\n    RehydrationError = \"dehydration.RehydrationError\",\n\n    /**\n     * Fires when a dehydrated device key has been cached in the local database.\n     */\n    DehydrationKeyCached = \"dehydration.DehydrationKeyCached\",\n\n    /**\n     * Fires when an error occurs during periodic rotation of the dehydrated device.\n     *\n     * The payload is an error message as a string.\n     */\n    DehydratedDeviceRotationError = \"dehydration.DehydratedDeviceRotationError\",\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAYA,WAAW,0BAAXA,WAAW;EACnB;AACJ;AACA;AACA;EAJYA,WAAW;EAOnB;AACJ;AACA;AACA;EAVYA,WAAW;EAanB;AACJ;AACA;AACA;EAhBYA,WAAW;EAmBnB;AACJ;AACA;AACA;EAtBYA,WAAW;EAyBnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAjCYA,WAAW;EAoCnB;AACJ;AACA;AACA;EAvCYA,WAAW;EA0CnB;EA1CQA,WAAW;EA6CnB;AACJ;AACA;AACA;EAhDYA,WAAW;EAmDnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EA9DYA,WAAW;EAiEnB;AACJ;AACA;AACA;AACA;AACA;AACA;EAvEYA,WAAW;EA0EnB;AACJ;AACA;AACA;AACA;AACA;AACA;EAhFYA,WAAW;EAmFnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EA3FYA,WAAW;EA8FnB;AACJ;AACA;AACA;AACA;AACA;EAnGYA,WAAW;EAsGnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EA7GYA,WAAW;EAgHnB;EAhHQA,WAAW;EAmHnB;AACJ;AACA;AACA;EAtHYA,WAAW;EAyHnB;AACJ;AACA;EA3HYA,WAAW;EA8HnB;AACJ;AACA;AACA;AACA;EAlIYA,WAAW;EAAA,OAAXA,WAAW;AAAA","ignoreList":[]}