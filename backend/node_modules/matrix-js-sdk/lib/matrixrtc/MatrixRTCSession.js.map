{"version":3,"file":"MatrixRTCSession.js","names":["logger","rootLogger","TypedEventEmitter","EventTimeline","EventType","CallMembership","RoomStateEvent","KnownMembership","MembershipManager","EncryptionManager","LegacyMembershipManager","logDurationSync","RoomKeyTransport","RoomAndToDeviceEvents","RoomAndToDeviceTransport","TypedReEmitter","ToDeviceKeyTransport","MatrixRTCSessionEvent","MatrixRTCSession","callId","_callId","callMembershipsForRoom","room","getChild","concat","roomId","roomState","getLiveTimeline","getState","FORWARDS","warn","Error","callMemberEvents","getStateEvents","GroupCallMemberPrefix","callMemberships","memberEvent","content","getContent","eventKeysCount","Object","keys","length","membershipContents","push","membershipData","_membership$sender","membership","scope","info","isExpired","sender","deviceId","hasMembershipState","Join","e","sort","a","b","createdTs","debug","map","m","roomSessionForRoom","client","roomSubset","constructor","memberships","_memberships$","_defineProperty","counters","roomEventEncryptionKeysSent","roomEventEncryptionKeysReceived","totals","roomEventEncryptionKeysReceivedTotalAge","recalculateSessionMembers","_this$_callId","_this$memberships$","_this$encryptionManag","oldMemberships","changed","some","i","equal","_this$membershipManag","emit","MembershipsChanged","membershipManager","onRTCSessionMemberUpdate","encryptionManager","onMembershipsUpdate","setExpiryTimer","on","Members","onRoomMemberUpdate","isJoined","_this$membershipManag2","_this$membershipManag3","stop","_this","_asyncToGenerator","_this$membershipManag4","leave","expiryTimeout","clearTimeout","undefined","off","joinRoomSession","fociPreferred","fociActive","joinConfig","_joinConfig$useNewMem","useNewMembershipManager","getOldestMembership","transport","useExperimentalToDeviceTransport","uId","dId","getUserId","getDeviceId","statistics","roomKeyTransport","toDeviceTransport","reEmitter","reEmit","EnabledTransportsChanged","keyBin","encryptionKeyIndex","participantId","EncryptionKeyChanged","join","error","MembershipManagerError","JoinStateChanged","leaveRoomSession","_arguments","arguments","_this2","timeout","leavePromise","getActiveFocus","_this$membershipManag5","getFocusInUse","oldestMembership","getFocusSelection","getPreferredFoci","reemitEncryptionKeys","_this$encryptionManag2","getEncryptionKeys","forEach","key","index","_this$encryptionManag3","_this$encryptionManag4","Map","Array","from","entries","_ref","k","values","soonestExpiry","thisExpiry","getMsUntilExpiry","setTimeout"],"sources":["../../src/matrixrtc/MatrixRTCSession.ts"],"sourcesContent":["/*\nCopyright 2023 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type Logger, logger as rootLogger } from \"../logger.ts\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { EventTimeline } from \"../models/event-timeline.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { EventType } from \"../@types/event.ts\";\nimport { CallMembership } from \"./CallMembership.ts\";\nimport { RoomStateEvent } from \"../models/room-state.ts\";\nimport { type Focus } from \"./focus.ts\";\nimport { KnownMembership } from \"../@types/membership.ts\";\nimport { MembershipManager } from \"./NewMembershipManager.ts\";\nimport { EncryptionManager, type IEncryptionManager } from \"./EncryptionManager.ts\";\nimport { LegacyMembershipManager } from \"./LegacyMembershipManager.ts\";\nimport { logDurationSync } from \"../utils.ts\";\nimport { type Statistics } from \"./types.ts\";\nimport { RoomKeyTransport } from \"./RoomKeyTransport.ts\";\nimport type { IMembershipManager } from \"./IMembershipManager.ts\";\nimport {\n    RoomAndToDeviceEvents,\n    type RoomAndToDeviceEventsHandlerMap,\n    RoomAndToDeviceTransport,\n} from \"./RoomAndToDeviceKeyTransport.ts\";\nimport { TypedReEmitter } from \"../ReEmitter.ts\";\nimport { ToDeviceKeyTransport } from \"./ToDeviceKeyTransport.ts\";\n\nexport enum MatrixRTCSessionEvent {\n    // A member joined, left, or updated a property of their membership.\n    MembershipsChanged = \"memberships_changed\",\n    // We joined or left the session: our own local idea of whether we are joined,\n    // separate from MembershipsChanged, ie. independent of whether our member event\n    // has successfully gone through.\n    JoinStateChanged = \"join_state_changed\",\n    // The key used to encrypt media has changed\n    EncryptionKeyChanged = \"encryption_key_changed\",\n    /** The membership manager had to shut down caused by an unrecoverable error */\n    MembershipManagerError = \"membership_manager_error\",\n}\n\nexport type MatrixRTCSessionEventHandlerMap = {\n    [MatrixRTCSessionEvent.MembershipsChanged]: (\n        oldMemberships: CallMembership[],\n        newMemberships: CallMembership[],\n    ) => void;\n    [MatrixRTCSessionEvent.JoinStateChanged]: (isJoined: boolean) => void;\n    [MatrixRTCSessionEvent.EncryptionKeyChanged]: (\n        key: Uint8Array,\n        encryptionKeyIndex: number,\n        participantId: string,\n    ) => void;\n    [MatrixRTCSessionEvent.MembershipManagerError]: (error: unknown) => void;\n};\n// The names follow these principles:\n// - we use the technical term delay if the option is related to delayed events.\n// - we use delayedLeaveEvent if the option is related to the delayed leave event.\n// - we use membershipEvent if the option is related to the rtc member state event.\n// - we use the technical term expiry if the option is related to the expiry field of the membership state event.\n// - we use a `MS` postfix if the option is a duration to avoid using words like:\n//   `time`, `duration`, `delay`, `timeout`... that might be mistaken/confused with technical terms.\nexport interface MembershipConfig {\n    /**\n     * Use the new Manager.\n     *\n     * Default: `false`.\n     */\n    useNewMembershipManager?: boolean;\n\n    /**\n     * The timeout (in milliseconds) after we joined the call, that our membership should expire\n     * unless we have explicitly updated it.\n     *\n     * This is what goes into the m.rtc.member event expiry field and is typically set to a number of hours.\n     */\n    membershipEventExpiryMs?: number;\n    /** @deprecated renamed to `membershipEventExpiryMs`*/\n    membershipExpiryTimeout?: number;\n\n    /**\n     * The time in (in milliseconds) which the manager will prematurely send the updated state event before the membership `expires` time to make sure it\n     * sends the updated state event early enough.\n     *\n     * A headroom of 1000ms and a `membershipExpiryTimeout` of 10000ms would result in the first membership event update after 9s and\n     * a membership event that would be considered expired after 10s.\n     *\n     * This value does not have an effect on the value of `SessionMembershipData.expires`.\n     */\n    membershipEventExpiryHeadroomMs?: number;\n    /** @deprecated  renamed to `membershipEventExpiryHeadroomMs`*/\n    membershipExpiryTimeoutHeadroom?: number;\n\n    /**\n     * The timeout (in milliseconds) with which the deleayed leave event on the server is configured.\n     * After this time the server will set the event to the disconnected stat if it has not received a keep-alive from the client.\n     */\n    delayedLeaveEventDelayMs?: number;\n    /** @deprecated renamed to `delayedLeaveEventDelayMs`*/\n    membershipServerSideExpiryTimeout?: number;\n\n    /**\n     * The interval (in milliseconds) in which the client will send membership keep-alives to the server.\n     */\n    delayedLeaveEventRestartMs?: number;\n    /** @deprecated renamed to `delayedLeaveEventRestartMs`*/\n    membershipKeepAlivePeriod?: number;\n\n    /**\n     * The maximum number of retries that the manager will do for delayed event sending/updating and state event sending when a server rate limit has been hit.\n     */\n    maximumRateLimitRetryCount?: number;\n\n    /**\n     * The maximum number of retries that the manager will do for delayed event sending/updating and state event sending when a network error occurs.\n     */\n    maximumNetworkErrorRetryCount?: number;\n\n    /**\n     * The time (in milliseconds) after which we will retry a http request if it\n     * failed to send due to a network error. (send membership event, send delayed event, restart delayed event...)\n     */\n    networkErrorRetryMs?: number;\n    /** @deprecated renamed to `networkErrorRetryMs`*/\n    callMemberEventRetryDelayMinimum?: number;\n\n    /**\n     * If true, use the new to-device transport for sending encryption keys.\n     */\n    useExperimentalToDeviceTransport?: boolean;\n}\n\nexport interface EncryptionConfig {\n    /**\n     *  If true, generate and share a media key for this participant,\n     *  and emit MatrixRTCSessionEvent.EncryptionKeyChanged when\n     *  media keys for other participants become available.\n     */\n    manageMediaKeys?: boolean;\n    /**\n     * The minimum time (in milliseconds) between each attempt to send encryption key(s).\n     * e.g. if this is set to 1000, then we will send at most one key event every second.\n     */\n    updateEncryptionKeyThrottle?: number;\n    /**\n     * The delay (in milliseconds) after a member leaves before we create and publish a new key, because people\n     * tend to leave calls at the same time.\n     */\n    makeKeyDelay?: number;\n    /**\n     * The delay (in milliseconds) between creating and sending a new key and starting to encrypt with it. This\n     * gives other a chance to receive the new key to minimise the chance they don't get media they can't decrypt.\n     * The total time between a member leaving and the call switching to new keys is therefore:\n     * makeKeyDelay + useKeyDelay\n     */\n    useKeyDelay?: number;\n}\nexport type JoinSessionConfig = MembershipConfig & EncryptionConfig;\n\n/**\n * A MatrixRTCSession manages the membership & properties of a MatrixRTC session.\n * This class doesn't deal with media at all, just membership & properties of a session.\n */\nexport class MatrixRTCSession extends TypedEventEmitter<\n    MatrixRTCSessionEvent | RoomAndToDeviceEvents,\n    MatrixRTCSessionEventHandlerMap & RoomAndToDeviceEventsHandlerMap\n> {\n    private membershipManager?: IMembershipManager;\n    private encryptionManager?: IEncryptionManager;\n    // The session Id of the call, this is the call_id of the call Member event.\n    private _callId: string | undefined;\n    private logger: Logger;\n    /**\n     * This timeout is responsible to track any expiration. We need to know when we have to start\n     * to ignore other call members. There is no callback for this. This timeout will always be configured to\n     * emit when the next membership expires.\n     */\n    private expiryTimeout?: ReturnType<typeof setTimeout>;\n\n    /**\n     * The statistics for this session.\n     */\n    public statistics: Statistics = {\n        counters: {\n            roomEventEncryptionKeysSent: 0,\n            roomEventEncryptionKeysReceived: 0,\n        },\n        totals: {\n            roomEventEncryptionKeysReceivedTotalAge: 0,\n        },\n    };\n\n    /**\n     * The callId (sessionId) of the call.\n     *\n     * It can be undefined since the callId is only known once the first membership joins.\n     * The callId is the property that, per definition, groups memberships into one call.\n     */\n    public get callId(): string | undefined {\n        return this._callId;\n    }\n\n    /**\n     * Returns all the call memberships for a room, oldest first\n     */\n    public static callMembershipsForRoom(\n        room: Pick<Room, \"getLiveTimeline\" | \"roomId\" | \"hasMembershipState\">,\n    ): CallMembership[] {\n        const logger = rootLogger.getChild(`[MatrixRTCSession ${room.roomId}]`);\n        const roomState = room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        if (!roomState) {\n            logger.warn(\"Couldn't get state for room \" + room.roomId);\n            throw new Error(\"Could't get state for room \" + room.roomId);\n        }\n        const callMemberEvents = roomState.getStateEvents(EventType.GroupCallMemberPrefix);\n\n        const callMemberships: CallMembership[] = [];\n        for (const memberEvent of callMemberEvents) {\n            const content = memberEvent.getContent();\n            const eventKeysCount = Object.keys(content).length;\n            // Dont even bother about empty events (saves us from costly type/\"key in\" checks in bigger rooms)\n            if (eventKeysCount === 0) continue;\n\n            const membershipContents: any[] = [];\n\n            // We first decide if its a MSC4143 event (per device state key)\n            if (eventKeysCount > 1 && \"focus_active\" in content) {\n                // We have a MSC4143 event membership event\n                membershipContents.push(content);\n            } else if (eventKeysCount === 1 && \"memberships\" in content) {\n                logger.warn(`Legacy event found. Those are ignored, they do not contribute to the MatrixRTC session`);\n            }\n\n            if (membershipContents.length === 0) continue;\n\n            for (const membershipData of membershipContents) {\n                try {\n                    const membership = new CallMembership(memberEvent, membershipData);\n\n                    if (membership.callId !== \"\" || membership.scope !== \"m.room\") {\n                        // for now, just ignore anything that isn't a room scope call\n                        logger.info(`Ignoring user-scoped call`);\n                        continue;\n                    }\n\n                    if (membership.isExpired()) {\n                        logger.info(`Ignoring expired device membership ${membership.sender}/${membership.deviceId}`);\n                        continue;\n                    }\n                    if (!room.hasMembershipState(membership.sender ?? \"\", KnownMembership.Join)) {\n                        logger.info(`Ignoring membership of user ${membership.sender} who is not in the room.`);\n                        continue;\n                    }\n                    callMemberships.push(membership);\n                } catch (e) {\n                    logger.warn(\"Couldn't construct call membership: \", e);\n                }\n            }\n        }\n\n        callMemberships.sort((a, b) => a.createdTs() - b.createdTs());\n        if (callMemberships.length > 1) {\n            logger.debug(\n                `Call memberships in room ${room.roomId}, in order: `,\n                callMemberships.map((m) => [m.createdTs(), m.sender]),\n            );\n        }\n\n        return callMemberships;\n    }\n\n    /**\n     * Return the MatrixRTC session for the room, whether there are currently active members or not\n     */\n    public static roomSessionForRoom(client: MatrixClient, room: Room): MatrixRTCSession {\n        const callMemberships = MatrixRTCSession.callMembershipsForRoom(room);\n\n        return new MatrixRTCSession(client, room, callMemberships);\n    }\n\n    /**\n     * WARN: this can in theory only be a subset of the room with the properties required by\n     * this class.\n     * Outside of tests this most likely will be a full room, however.\n     * @deprecated Relying on a full Room object being available here is an anti-pattern. You should be tracking\n     * the room object in your own code and passing it in when needed.\n     */\n    public get room(): Room {\n        return this.roomSubset as Room;\n    }\n\n    /**\n     * This constructs a room session. When using MatrixRTC inside the js-sdk this is expected\n     * to be used with the MatrixRTCSessionManager exclusively.\n     *\n     * In cases where you don't use the js-sdk but build on top of another Matrix stack this class can be used standalone\n     * to manage a joined MatrixRTC session.\n     *\n     * @param client A subset of the {@link MatrixClient} that lets the session interact with the Matrix room.\n     * @param roomSubset The room this session is attached to. A subset of a js-sdk Room that the session needs.\n     * @param memberships The list of memberships this session currently has.\n     */\n    public constructor(\n        private readonly client: Pick<\n            MatrixClient,\n            | \"getUserId\"\n            | \"getDeviceId\"\n            | \"sendStateEvent\"\n            | \"_unstable_sendDelayedStateEvent\"\n            | \"_unstable_updateDelayedEvent\"\n            | \"sendEvent\"\n            | \"cancelPendingEvent\"\n            | \"encryptAndSendToDevice\"\n            | \"off\"\n            | \"on\"\n            | \"decryptEventIfNeeded\"\n        >,\n        private roomSubset: Pick<\n            Room,\n            \"getLiveTimeline\" | \"roomId\" | \"getVersion\" | \"hasMembershipState\" | \"on\" | \"off\"\n        >,\n        public memberships: CallMembership[],\n    ) {\n        super();\n        this.logger = rootLogger.getChild(`[MatrixRTCSession ${roomSubset.roomId}]`);\n        this._callId = memberships[0]?.callId;\n        const roomState = this.roomSubset.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        // TODO: double check if this is actually needed. Should be covered by refreshRoom in MatrixRTCSessionManager\n        roomState?.on(RoomStateEvent.Members, this.onRoomMemberUpdate);\n        this.setExpiryTimer();\n    }\n\n    /*\n     * Returns true if we intend to be participating in the MatrixRTC session.\n     * This is determined by checking if the relativeExpiry has been set.\n     */\n    public isJoined(): boolean {\n        return this.membershipManager?.isJoined() ?? false;\n    }\n\n    /**\n     * Performs cleanup & removes timers for client shutdown\n     */\n    public async stop(): Promise<void> {\n        await this.membershipManager?.leave(1000);\n        if (this.expiryTimeout) {\n            clearTimeout(this.expiryTimeout);\n            this.expiryTimeout = undefined;\n        }\n        const roomState = this.roomSubset.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        roomState?.off(RoomStateEvent.Members, this.onRoomMemberUpdate);\n    }\n    private reEmitter = new TypedReEmitter<\n        MatrixRTCSessionEvent | RoomAndToDeviceEvents,\n        MatrixRTCSessionEventHandlerMap & RoomAndToDeviceEventsHandlerMap\n    >(this);\n\n    /**\n     * Announces this user and device as joined to the MatrixRTC session,\n     * and continues to update the membership event to keep it valid until\n     * leaveRoomSession() is called\n     * This will not subscribe to updates: remember to call subscribe() separately if\n     * desired.\n     * This method will return immediately and the session will be joined in the background.\n     *\n     * @param fociActive - The object representing the active focus. (This depends on the focus type.)\n     * @param fociPreferred - The list of preferred foci this member proposes to use/knows/has access to.\n     *                        For the livekit case this is a list of foci generated from the homeserver well-known, the current rtc session,\n     *                        or optionally other room members homeserver well known.\n     * @param joinConfig - Additional configuration for the joined session.\n     */\n    public joinRoomSession(fociPreferred: Focus[], fociActive?: Focus, joinConfig?: JoinSessionConfig): void {\n        if (this.isJoined()) {\n            this.logger.info(`Already joined to session in room ${this.roomSubset.roomId}: ignoring join call`);\n            return;\n        } else {\n            // Create MembershipManager and pass the RTCSession logger (with room id info)\n            if (joinConfig?.useNewMembershipManager ?? false) {\n                this.membershipManager = new MembershipManager(\n                    joinConfig,\n                    this.roomSubset,\n                    this.client,\n                    () => this.getOldestMembership(),\n                    this.logger,\n                );\n            } else {\n                this.membershipManager = new LegacyMembershipManager(joinConfig, this.roomSubset, this.client, () =>\n                    this.getOldestMembership(),\n                );\n            }\n            // Create Encryption manager\n            let transport;\n            if (joinConfig?.useExperimentalToDeviceTransport) {\n                this.logger.info(\"Using to-device with room fallback transport for encryption keys\");\n                const [uId, dId] = [this.client.getUserId()!, this.client.getDeviceId()!];\n                const [room, client, statistics] = [this.roomSubset, this.client, this.statistics];\n                // Deprecate RoomKeyTransport: only ToDeviceKeyTransport is needed once deprecated\n                const roomKeyTransport = new RoomKeyTransport(room, client, statistics);\n                const toDeviceTransport = new ToDeviceKeyTransport(uId, dId, room.roomId, client, statistics);\n                transport = new RoomAndToDeviceTransport(toDeviceTransport, roomKeyTransport, this.logger);\n\n                // Expose the changes so the ui can display the currently used transport.\n                this.reEmitter.reEmit(transport, [RoomAndToDeviceEvents.EnabledTransportsChanged]);\n            } else {\n                transport = new RoomKeyTransport(this.roomSubset, this.client, this.statistics);\n            }\n            this.encryptionManager = new EncryptionManager(\n                this.client.getUserId()!,\n                this.client.getDeviceId()!,\n                () => this.memberships,\n                transport,\n                this.statistics,\n                (keyBin: Uint8Array, encryptionKeyIndex: number, participantId: string) => {\n                    this.emit(MatrixRTCSessionEvent.EncryptionKeyChanged, keyBin, encryptionKeyIndex, participantId);\n                },\n                this.logger,\n            );\n        }\n\n        // Join!\n        this.membershipManager!.join(fociPreferred, fociActive, (e) => {\n            this.logger.error(\"MembershipManager encountered an unrecoverable error: \", e);\n            this.emit(MatrixRTCSessionEvent.MembershipManagerError, e);\n            this.emit(MatrixRTCSessionEvent.JoinStateChanged, this.isJoined());\n        });\n        this.encryptionManager!.join(joinConfig);\n\n        this.emit(MatrixRTCSessionEvent.JoinStateChanged, true);\n    }\n\n    /**\n     * Announces this user and device as having left the MatrixRTC session\n     * and stops scheduled updates.\n     * This will not unsubscribe from updates: remember to call unsubscribe() separately if\n     * desired.\n     * The membership update required to leave the session will retry if it fails.\n     * Without network connection the promise will never resolve.\n     * A timeout can be provided so that there is a guarantee for the promise to resolve.\n     * @returns Whether the membership update was attempted and did not time out.\n     */\n    public async leaveRoomSession(timeout: number | undefined = undefined): Promise<boolean> {\n        if (!this.isJoined()) {\n            this.logger.info(`Not joined to session in room ${this.roomSubset.roomId}: ignoring leave call`);\n            return false;\n        }\n\n        this.logger.info(`Leaving call session in room ${this.roomSubset.roomId}`);\n\n        this.encryptionManager!.leave();\n\n        const leavePromise = this.membershipManager!.leave(timeout);\n        this.emit(MatrixRTCSessionEvent.JoinStateChanged, false);\n\n        return await leavePromise;\n    }\n\n    /**\n     * Get the active focus from the current CallMemberState event\n     * @returns The focus that is currently in use to connect to this session. This is undefined\n     * if the client is not connected to this session.\n     */\n    public getActiveFocus(): Focus | undefined {\n        return this.membershipManager?.getActiveFocus();\n    }\n\n    public getOldestMembership(): CallMembership | undefined {\n        return this.memberships[0];\n    }\n\n    /**\n     * This method is used when the user is not yet connected to the Session but wants to know what focus\n     * the users in the session are using to make a decision how it wants/should connect.\n     *\n     * See also `getActiveFocus`\n     * @returns The focus which should be used when joining this session.\n     */\n    public getFocusInUse(): Focus | undefined {\n        const oldestMembership = this.getOldestMembership();\n        if (oldestMembership?.getFocusSelection() === \"oldest_membership\") {\n            return oldestMembership.getPreferredFoci()[0];\n        }\n    }\n\n    /**\n     * Re-emit an EncryptionKeyChanged event for each tracked encryption key. This can be used to export\n     * the keys.\n     */\n    public reemitEncryptionKeys(): void {\n        this.encryptionManager?.getEncryptionKeys().forEach((keys, participantId) => {\n            keys.forEach((key, index) => {\n                this.emit(MatrixRTCSessionEvent.EncryptionKeyChanged, key.key, index, participantId);\n            });\n        });\n    }\n\n    /**\n     * A map of keys used to encrypt and decrypt (we are using a symmetric\n     * cipher) given participant's media. This also includes our own key\n     *\n     * @deprecated This will be made private in a future release.\n     */\n    public getEncryptionKeys(): IterableIterator<[string, Array<Uint8Array>]> {\n        const keys =\n            this.encryptionManager?.getEncryptionKeys() ??\n            new Map<string, Array<{ key: Uint8Array; timestamp: number }>>();\n        // the returned array doesn't contain the timestamps\n        return Array.from(keys.entries())\n            .map(([participantId, keys]): [string, Uint8Array[]] => [participantId, keys.map((k) => k.key)])\n            .values();\n    }\n\n    /**\n     * Sets a timer for the soonest membership expiry\n     */\n    private setExpiryTimer(): void {\n        if (this.expiryTimeout) {\n            clearTimeout(this.expiryTimeout);\n            this.expiryTimeout = undefined;\n        }\n\n        let soonestExpiry;\n        for (const membership of this.memberships) {\n            const thisExpiry = membership.getMsUntilExpiry();\n            // If getMsUntilExpiry is undefined we have a MSC4143 (MatrixRTC) compliant event - it never expires\n            // but will be reliably resent on disconnect.\n            if (thisExpiry !== undefined && (soonestExpiry === undefined || thisExpiry < soonestExpiry)) {\n                soonestExpiry = thisExpiry;\n            }\n        }\n\n        if (soonestExpiry != undefined) {\n            this.expiryTimeout = setTimeout(this.onRTCSessionMemberUpdate, soonestExpiry);\n        }\n    }\n\n    /**\n     * Call this when the Matrix room members have changed.\n     */\n    public onRoomMemberUpdate = (): void => {\n        this.recalculateSessionMembers();\n    };\n\n    /**\n     * Call this when something changed that may impacts the current MatrixRTC members in this session.\n     */\n    public onRTCSessionMemberUpdate = (): void => {\n        this.recalculateSessionMembers();\n    };\n\n    /**\n     * Call this when anything that could impact rtc memberships has changed: Room Members or RTC members.\n     *\n     * Examines the latest call memberships and handles any encryption key sending or rotation that is needed.\n     *\n     * This function should be called when the room members or call memberships might have changed.\n     */\n    private recalculateSessionMembers = (): void => {\n        const oldMemberships = this.memberships;\n        this.memberships = MatrixRTCSession.callMembershipsForRoom(this.room);\n\n        this._callId = this._callId ?? this.memberships[0]?.callId;\n\n        const changed =\n            oldMemberships.length != this.memberships.length ||\n            oldMemberships.some((m, i) => !CallMembership.equal(m, this.memberships[i]));\n\n        if (changed) {\n            this.logger.info(\n                `Memberships for call in room ${this.roomSubset.roomId} have changed: emitting (${this.memberships.length} members)`,\n            );\n            logDurationSync(this.logger, \"emit MatrixRTCSessionEvent.MembershipsChanged\", () => {\n                this.emit(MatrixRTCSessionEvent.MembershipsChanged, oldMemberships, this.memberships);\n            });\n\n            void this.membershipManager?.onRTCSessionMemberUpdate(this.memberships);\n        }\n        // This also needs to be done if `changed` = false\n        // A member might have updated their fingerprint (created_ts)\n        void this.encryptionManager?.onMembershipsUpdate(oldMemberships);\n\n        this.setExpiryTimer();\n    };\n}\n"],"mappings":"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","ignoreList":[]}