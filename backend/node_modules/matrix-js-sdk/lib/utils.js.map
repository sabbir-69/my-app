{"version":3,"file":"utils.js","names":["unhomoglyph","promiseRetry","M_TIMESTAMP","ReceiptType","interns","Map","internaliseString","str","String","toString","has","set","get","encodeParams","params","urlSearchParams","searchParams","URLSearchParams","_loop","key","val","undefined","Array","isArray","forEach","v","append","Object","entries","replaceParam","stable","unstable","dict","result","_objectSpread","decodeParams","query","o","keys","getAll","length","encodeUri","pathTemplate","variables","hasOwnProperty","value","replace","encodeURIComponent","removeElement","array","fn","reverse","i","splice","isFunction","prototype","call","checkObjectHasKeys","obj","Error","deepCopy","JSON","parse","stringify","deepCompare","x","y","isNaN","constructor","RegExp","Date","p","deepSortedObjectEntries","pairs","k","push","sort","a","b","lexicographicCompare","isNumber","isFinite","removeHiddenChars","normalize","removeHiddenCharsRegex","removeDirectionOverrideChars","toLowerCase","escapeRegExp","string","globToRegexp","glob","ensureNoTrailingSlash","url","endsWith","slice","sleep","ms","Promise","resolve","setTimeout","logDuration","_x","_x2","_x3","_logDuration","apply","arguments","_asyncToGenerator","logger","name","block","start","now","end","debug","concat","logDurationSync","immediate","isNullOrUndefined","defer","withResolvers","promiseMapSeries","_x4","_x5","_promiseMapSeries","promises","promiseTry","chunkPromises","_x6","_x7","_chunkPromises","fns","chunkSize","results","all","map","simpleRetryOperation","promiseFn","attempt","forever","factor","minTimeout","maxTimeout","DEFAULT_ALPHABET","c","fromCharCode","alphabetPad","s","n","alphabet","padEnd","baseToString","len","BigInt","_alphabet","Number","d","r","Math","abs","stringToBase","j","charIndex","charCodeAt","averageBetweenStrings","padN","max","baseA","baseB","avg","nextString","prevString","recursivelyAssign","target","source","ignoreNullish","sourceKey","sourceValue","safeSet","getContentTimestampWithFallback","event","_M_TIMESTAMP$findIn","findIn","getContent","sortEventsByLatestContentTimestamp","left","right","isSupportedReceiptType","receiptType","Read","ReadPrivate","includes","mapsEqual","eq","v1","v2","size","processMapToObjectValue","recursiveMapToObject","targetMap","fromEntries","unsafeProp","prop","noUnsafeEventProps","room_id","sender","event_id","MapWithDefault","createDefault","getOrCreate"],"sources":["../src/utils.ts"],"sourcesContent":["/*\nCopyright 2015, 2016, 2019, 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module.\n */\n\nimport unhomoglyph from \"unhomoglyph\";\nimport promiseRetry from \"p-retry\";\nimport { type Optional } from \"matrix-events-sdk\";\n\nimport { type IEvent, type MatrixEvent } from \"./models/event.ts\";\nimport { M_TIMESTAMP } from \"./@types/location.ts\";\nimport { ReceiptType } from \"./@types/read_receipts.ts\";\nimport { type BaseLogger } from \"./logger.ts\";\n\nconst interns = new Map<string, string>();\n\n/**\n * Internalises a string, reusing a known pointer or storing the pointer\n * if needed for future strings.\n * @param str - The string to internalise.\n * @returns The internalised string.\n */\nexport function internaliseString(str: string): string {\n    // Unwrap strings before entering the map, if we somehow got a wrapped\n    // string as our input. This should only happen from tests.\n    if ((str as unknown) instanceof String) {\n        str = str.toString();\n    }\n\n    // Check the map to see if we can store the value\n    if (!interns.has(str)) {\n        interns.set(str, str);\n    }\n\n    // Return any cached string reference\n    return interns.get(str)!;\n}\n\n/**\n * Encode a dictionary of query parameters.\n * Omits any undefined/null values.\n * @param params - A dict of key/values to encode e.g.\n * `{\"foo\": \"bar\", \"baz\": \"taz\"}`\n * @returns The encoded string e.g. foo=bar&baz=taz\n */\nexport function encodeParams(params: QueryDict, urlSearchParams?: URLSearchParams): URLSearchParams {\n    const searchParams = urlSearchParams ?? new URLSearchParams();\n    for (const [key, val] of Object.entries(params)) {\n        if (val !== undefined && val !== null) {\n            if (Array.isArray(val)) {\n                val.forEach((v) => {\n                    searchParams.append(key, String(v));\n                });\n            } else {\n                searchParams.append(key, String(val));\n            }\n        }\n    }\n    return searchParams;\n}\n\nexport type QueryDict = Record<string, string[] | string | number | boolean | undefined>;\n\n/**\n * Replace a stable parameter with the unstable naming for params\n */\nexport function replaceParam(stable: string, unstable: string, dict: QueryDict): QueryDict {\n    const result = {\n        ...dict,\n        [unstable]: dict[stable],\n    };\n    delete result[stable];\n    return result;\n}\n\n/**\n * Decode a query string in `application/x-www-form-urlencoded` format.\n * @param query - A query string to decode e.g.\n * foo=bar&via=server1&server2\n * @returns The decoded object, if any keys occurred multiple times\n * then the value will be an array of strings, else it will be an array.\n * This behaviour matches Node's qs.parse but is built on URLSearchParams\n * for native web compatibility\n */\nexport function decodeParams(query: string): Record<string, string | string[]> {\n    const o: Record<string, string | string[]> = {};\n    const params = new URLSearchParams(query);\n    for (const key of params.keys()) {\n        const val = params.getAll(key);\n        o[key] = val.length === 1 ? val[0] : val;\n    }\n    return o;\n}\n\n/**\n * Encodes a URI according to a set of template variables. Variables will be\n * passed through encodeURIComponent.\n * @param pathTemplate - The path with template variables e.g. '/foo/$bar'.\n * @param variables - The key/value pairs to replace the template\n * variables with. E.g. `{ \"$bar\": \"baz\" }`.\n * @returns The result of replacing all template variables e.g. '/foo/baz'.\n */\nexport function encodeUri(pathTemplate: string, variables: Record<string, Optional<string>>): string {\n    for (const key in variables) {\n        if (!variables.hasOwnProperty(key)) {\n            continue;\n        }\n        const value = variables[key];\n        if (value === undefined || value === null) {\n            continue;\n        }\n        pathTemplate = pathTemplate.replace(key, encodeURIComponent(value));\n    }\n    return pathTemplate;\n}\n\n/**\n * The removeElement() method removes the first element in the array that\n * satisfies (returns true) the provided testing function.\n * @param array - The array.\n * @param fn - Function to execute on each value in the array, with the\n * function signature `fn(element, index, array)`. Return true to\n * remove this element and break.\n * @param reverse - True to search in reverse order.\n * @returns True if an element was removed.\n */\nexport function removeElement<T>(array: T[], fn: (t: T, i?: number, a?: T[]) => boolean, reverse?: boolean): boolean {\n    let i: number;\n    if (reverse) {\n        for (i = array.length - 1; i >= 0; i--) {\n            if (fn(array[i], i, array)) {\n                array.splice(i, 1);\n                return true;\n            }\n        }\n    } else {\n        for (i = 0; i < array.length; i++) {\n            if (fn(array[i], i, array)) {\n                array.splice(i, 1);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Checks if the given thing is a function.\n * @param value - The thing to check.\n * @returns True if it is a function.\n */\nexport function isFunction(value: any): boolean {\n    return Object.prototype.toString.call(value) === \"[object Function]\";\n}\n\n/**\n * Checks that the given object has the specified keys.\n * @param obj - The object to check.\n * @param keys - The list of keys that 'obj' must have.\n * @throws If the object is missing keys.\n */\n// note using 'keys' here would shadow the 'keys' function defined above\nexport function checkObjectHasKeys(obj: object, keys: string[]): void {\n    for (const key of keys) {\n        if (!obj.hasOwnProperty(key)) {\n            throw new Error(\"Missing required key: \" + key);\n        }\n    }\n}\n\n/**\n * Deep copy the given object. The object MUST NOT have circular references and\n * MUST NOT have functions.\n * @param obj - The object to deep copy.\n * @returns A copy of the object without any references to the original.\n */\nexport function deepCopy<T>(obj: T): T {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Compare two objects for equality. The objects MUST NOT have circular references.\n *\n * @param x - The first object to compare.\n * @param y - The second object to compare.\n *\n * @returns true if the two objects are equal\n */\nexport function deepCompare(x: any, y: any): boolean {\n    // Inspired by\n    // http://stackoverflow.com/questions/1068834/object-comparison-in-javascript#1144249\n\n    // Compare primitives and functions.\n    // Also check if both arguments link to the same object.\n    if (x === y) {\n        return true;\n    }\n\n    if (typeof x !== typeof y) {\n        return false;\n    }\n\n    // special-case NaN (since NaN !== NaN)\n    if (typeof x === \"number\" && isNaN(x) && isNaN(y)) {\n        return true;\n    }\n\n    // special-case null (since typeof null == 'object', but null.constructor\n    // throws)\n    if (x === null || y === null) {\n        return x === y;\n    }\n\n    // everything else is either an unequal primitive, or an object\n    if (!(x instanceof Object)) {\n        return false;\n    }\n\n    // check they are the same type of object\n    if (x.constructor !== y.constructor || x.prototype !== y.prototype) {\n        return false;\n    }\n\n    // special-casing for some special types of object\n    if (x instanceof RegExp || x instanceof Date) {\n        return x.toString() === y.toString();\n    }\n\n    // the object algorithm works for Array, but it's sub-optimal.\n    if (Array.isArray(x)) {\n        if (x.length !== y.length) {\n            return false;\n        }\n\n        for (let i = 0; i < x.length; i++) {\n            if (!deepCompare(x[i], y[i])) {\n                return false;\n            }\n        }\n    } else {\n        // check that all of y's direct keys are in x\n        for (const p in y) {\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n                return false;\n            }\n        }\n\n        // finally, compare each of x's keys with y\n        for (const p in x) {\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p) || !deepCompare(x[p], y[p])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// Dev note: This returns an array of tuples, but jsdoc doesn't like that. https://github.com/jsdoc/jsdoc/issues/1703\n/**\n * Creates an array of object properties/values (entries) then\n * sorts the result by key, recursively. The input object must\n * ensure it does not have loops. If the input is not an object\n * then it will be returned as-is.\n * @param obj - The object to get entries of\n * @returns The entries, sorted by key.\n */\nexport function deepSortedObjectEntries(obj: any): [string, any][] {\n    if (typeof obj !== \"object\") return obj;\n\n    // Apparently these are object types...\n    if (obj === null || obj === undefined || Array.isArray(obj)) return obj;\n\n    const pairs: [string, any][] = [];\n    for (const [k, v] of Object.entries(obj)) {\n        pairs.push([k, deepSortedObjectEntries(v)]);\n    }\n\n    // lexicographicCompare is faster than localeCompare, so let's use that.\n    pairs.sort((a, b) => lexicographicCompare(a[0], b[0]));\n\n    return pairs;\n}\n\n/**\n * Returns whether the given value is a finite number without type-coercion\n *\n * @param value - the value to test\n * @returns whether or not value is a finite number without type-coercion\n */\nexport function isNumber(value: any): value is number {\n    return typeof value === \"number\" && isFinite(value);\n}\n\n/**\n * Removes zero width chars, diacritics and whitespace from the string\n * Also applies an unhomoglyph on the string, to prevent similar looking chars\n * @param str - the string to remove hidden characters from\n * @returns a string with the hidden characters removed\n */\nexport function removeHiddenChars(str: string): string {\n    if (typeof str === \"string\") {\n        return unhomoglyph(str.normalize(\"NFD\").replace(removeHiddenCharsRegex, \"\"));\n    }\n    return \"\";\n}\n\n/**\n * Removes the direction override characters from a string\n * @returns string with chars removed\n */\nexport function removeDirectionOverrideChars(str: string): string {\n    if (typeof str === \"string\") {\n        return str.replace(/[\\u202d-\\u202e]/g, \"\");\n    }\n    return \"\";\n}\n\nexport function normalize(str: string): string {\n    // Note: we have to match the filter with the removeHiddenChars() because the\n    // function strips spaces and other characters (M becomes RN for example, in lowercase).\n    return (\n        removeHiddenChars(str.toLowerCase())\n            // Strip all punctuation\n            .replace(/[\\\\'!\"#$%&()*+,\\-./:;<=>?@[\\]^_`{|}~\\u2000-\\u206f\\u2e00-\\u2e7f]/g, \"\")\n            // We also doubly convert to lowercase to work around oddities of the library.\n            .toLowerCase()\n    );\n}\n\n// Regex matching bunch of unicode control characters and otherwise misleading/invisible characters.\n// Includes:\n// various width spaces U+2000 - U+200D\n// LTR and RTL marks U+200E and U+200F\n// LTR/RTL and other directional formatting marks U+202A - U+202F\n// Arabic Letter RTL mark U+061C\n// Combining characters U+0300 - U+036F\n// Zero width no-break space (BOM) U+FEFF\n// Blank/invisible characters (U2800, U2062-U2063)\n// eslint-disable-next-line no-misleading-character-class\nconst removeHiddenCharsRegex = /[\\u2000-\\u200F\\u202A-\\u202F\\u0300-\\u036F\\uFEFF\\u061C\\u2800\\u2062-\\u2063\\s]/g;\n\nexport function escapeRegExp(string: string): string {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\n/**\n * Converts Matrix glob-style string to a regular expression\n * https://spec.matrix.org/v1.7/appendices/#glob-style-matching\n * @param glob - Matrix glob-style string\n * @returns regular expression\n */\nexport function globToRegexp(glob: string): string {\n    return escapeRegExp(glob).replace(/\\\\\\*/g, \".*\").replace(/\\?/g, \".\");\n}\n\nexport function ensureNoTrailingSlash(url: string): string;\nexport function ensureNoTrailingSlash(url: undefined): undefined;\nexport function ensureNoTrailingSlash(url?: string): string | undefined;\nexport function ensureNoTrailingSlash(url?: string): string | undefined {\n    if (url?.endsWith(\"/\")) {\n        return url.slice(0, -1);\n    } else {\n        return url;\n    }\n}\n\n/**\n * Returns a promise which resolves with a given value after the given number of ms\n */\nexport function sleep<T>(ms: number, value?: T): Promise<T> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms, value);\n    });\n}\n\n/**\n * Utility to log the duration of a promise.\n *\n * @param logger - The logger to log to.\n * @param name - The name of the operation.\n * @param block - The block to execute.\n */\nexport async function logDuration<T>(logger: BaseLogger, name: string, block: () => Promise<T>): Promise<T> {\n    const start = Date.now();\n    try {\n        return await block();\n    } finally {\n        const end = Date.now();\n        logger.debug(`[Perf]: ${name} took ${end - start}ms`);\n    }\n}\n\n/**\n * Utility to log the duration of a synchronous block.\n *\n * @param logger - The logger to log to.\n * @param name - The name of the operation.\n * @param block - The block to execute.\n */\nexport function logDurationSync<T>(logger: BaseLogger, name: string, block: () => T): T {\n    const start = Date.now();\n    try {\n        return block();\n    } finally {\n        const end = Date.now();\n        logger.debug(`[Perf]: ${name} took ${end - start}ms`);\n    }\n}\n\n/**\n * Promise/async version of {@link setImmediate}.\n *\n * Implementation is based on `setTimeout` for wider compatibility.\n * @deprecated Use {@link sleep} instead.\n */\nexport function immediate(): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve));\n}\n\nexport function isNullOrUndefined(val: any): boolean {\n    return val === null || val === undefined;\n}\n/**\n * @deprecated use {@link PromiseWithResolvers} instead.\n */\nexport type IDeferred<T> = PromiseWithResolvers<T>;\n\n/**\n * Creates a deferred promise. This is a promise that can be resolved or rejected.\n * @deprecated use {@link Promise.withResolvers} instead.\n */\nexport function defer<T = void>(): IDeferred<T> {\n    return Promise.withResolvers<T>();\n}\n\nexport async function promiseMapSeries<T>(\n    promises: Array<T | Promise<T>>,\n    fn: (t: T) => Promise<unknown> | undefined, // if async we don't care about the type as we only await resolution\n): Promise<void> {\n    for (const o of promises) {\n        await fn(await o);\n    }\n}\n\nexport function promiseTry<T>(fn: () => T | Promise<T>): Promise<T> {\n    return Promise.resolve(fn());\n}\n\n// Creates and awaits all promises, running no more than `chunkSize` at the same time\nexport async function chunkPromises<T>(fns: (() => Promise<T>)[], chunkSize: number): Promise<T[]> {\n    const results: T[] = [];\n    for (let i = 0; i < fns.length; i += chunkSize) {\n        results.push(...(await Promise.all(fns.slice(i, i + chunkSize).map((fn) => fn()))));\n    }\n    return results;\n}\n\n/**\n * Retries the function until it succeeds or is interrupted. The given function must return\n * a promise which throws/rejects on error, otherwise the retry will assume the request\n * succeeded. The promise chain returned will contain the successful promise. The given function\n * should always return a new promise.\n * @param promiseFn - The function to call to get a fresh promise instance. Takes an\n * attempt count as an argument, for logging/debugging purposes.\n * @returns The promise for the retried operation.\n */\nexport function simpleRetryOperation<T>(promiseFn: (attempt: number) => Promise<T>): Promise<T> {\n    return promiseRetry(\n        (attempt: number) => {\n            return promiseFn(attempt);\n        },\n        {\n            forever: true,\n            factor: 2,\n            minTimeout: 3000, // ms\n            maxTimeout: 15000, // ms\n        },\n    );\n}\n\n// String averaging inspired by https://stackoverflow.com/a/2510816\n// Dev note: We make the alphabet a string because it's easier to write syntactically\n// than arrays. Thankfully, strings implement the useful parts of the Array interface\n// anyhow.\n\n/**\n * The default alphabet used by string averaging in this SDK. This matches\n * all usefully printable ASCII characters (0x20-0x7E, inclusive).\n */\nexport const DEFAULT_ALPHABET = ((): string => {\n    let str = \"\";\n    for (let c = 0x20; c <= 0x7e; c++) {\n        str += String.fromCharCode(c);\n    }\n    return str;\n})();\n\n/**\n * Pads a string using the given alphabet as a base. The returned string will be\n * padded at the end with the first character in the alphabet.\n *\n * This is intended for use with string averaging.\n * @param s - The string to pad.\n * @param n - The length to pad to.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The padded string.\n */\nexport function alphabetPad(s: string, n: number, alphabet = DEFAULT_ALPHABET): string {\n    return s.padEnd(n, alphabet[0]);\n}\n\n/**\n * Converts a baseN number to a string, where N is the alphabet's length.\n *\n * This is intended for use with string averaging.\n * @param n - The baseN number.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The baseN number encoded as a string from the alphabet.\n */\nexport function baseToString(n: bigint, alphabet = DEFAULT_ALPHABET): string {\n    // Developer note: the stringToBase() function offsets the character set by 1 so that repeated\n    // characters (ie: \"aaaaaa\" in a..z) don't come out as zero. We have to reverse this here as\n    // otherwise we'll be wrong in our conversion. Undoing a +1 before an exponent isn't very fun\n    // though, so we rely on a lengthy amount of `x - 1` and integer division rules to reach a\n    // sane state. This also means we have to do rollover detection: see below.\n\n    const len = BigInt(alphabet.length);\n    if (n <= len) {\n        return alphabet[Number(n) - 1] ?? \"\";\n    }\n\n    let d = n / len;\n    let r = Number(n % len) - 1;\n\n    // Rollover detection: if the remainder is negative, it means that the string needs\n    // to roll over by 1 character downwards (ie: in a..z, the previous to \"aaa\" would be\n    // \"zz\").\n    if (r < 0) {\n        d -= BigInt(Math.abs(r)); // abs() is just to be clear what we're doing. Could also `+= r`.\n        r = Number(len) - 1;\n    }\n\n    return baseToString(d, alphabet) + alphabet[r];\n}\n\n/**\n * Converts a string to a baseN number, where N is the alphabet's length.\n *\n * This is intended for use with string averaging.\n * @param s - The string to convert to a number.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The baseN number.\n */\nexport function stringToBase(s: string, alphabet = DEFAULT_ALPHABET): bigint {\n    const len = BigInt(alphabet.length);\n\n    // In our conversion to baseN we do a couple performance optimizations to avoid using\n    // excess CPU and such. To create baseN numbers, the input string needs to be reversed\n    // so the exponents stack up appropriately, as the last character in the unreversed\n    // string has less impact than the first character (in \"abc\" the A is a lot more important\n    // for lexicographic sorts). We also do a trick with the character codes to optimize the\n    // alphabet lookup, avoiding an index scan of `alphabet.indexOf(reversedStr[i])` - we know\n    // that the alphabet and (theoretically) the input string are constrained on character sets\n    // and thus can do simple subtraction to end up with the same result.\n\n    // Developer caution: we carefully cast to BigInt here to avoid losing precision. We cannot\n    // rely on Math.pow() (for example) to be capable of handling our insane numbers.\n\n    let result = BigInt(0);\n    for (let i = s.length - 1, j = BigInt(0); i >= 0; i--, j++) {\n        const charIndex = s.charCodeAt(i) - alphabet.charCodeAt(0);\n\n        // We add 1 to the char index to offset the whole numbering scheme. We unpack this in\n        // the baseToString() function.\n        result += BigInt(1 + charIndex) * len ** j;\n    }\n    return result;\n}\n\n/**\n * Averages two strings, returning the midpoint between them. This is accomplished by\n * converting both to baseN numbers (where N is the alphabet's length) then averaging\n * those before re-encoding as a string.\n * @param a - The first string.\n * @param b - The second string.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The midpoint between the strings, as a string.\n */\nexport function averageBetweenStrings(a: string, b: string, alphabet = DEFAULT_ALPHABET): string {\n    const padN = Math.max(a.length, b.length);\n    const baseA = stringToBase(alphabetPad(a, padN, alphabet), alphabet);\n    const baseB = stringToBase(alphabetPad(b, padN, alphabet), alphabet);\n    const avg = (baseA + baseB) / BigInt(2);\n\n    // Detect integer division conflicts. This happens when two numbers are divided too close so\n    // we lose a .5 precision. We need to add a padding character in these cases.\n    if (avg === baseA || avg == baseB) {\n        return baseToString(avg, alphabet) + alphabet[0];\n    }\n\n    return baseToString(avg, alphabet);\n}\n\n/**\n * Finds the next string using the alphabet provided. This is done by converting the\n * string to a baseN number, where N is the alphabet's length, then adding 1 before\n * converting back to a string.\n * @param s - The string to start at.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The string which follows the input string.\n */\nexport function nextString(s: string, alphabet = DEFAULT_ALPHABET): string {\n    return baseToString(stringToBase(s, alphabet) + BigInt(1), alphabet);\n}\n\n/**\n * Finds the previous string using the alphabet provided. This is done by converting the\n * string to a baseN number, where N is the alphabet's length, then subtracting 1 before\n * converting back to a string.\n * @param s - The string to start at.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The string which precedes the input string.\n */\nexport function prevString(s: string, alphabet = DEFAULT_ALPHABET): string {\n    return baseToString(stringToBase(s, alphabet) - BigInt(1), alphabet);\n}\n\n/**\n * Compares strings lexicographically as a sort-safe function.\n * @param a - The first (reference) string.\n * @param b - The second (compare) string.\n * @returns Negative if the reference string is before the compare string;\n * positive if the reference string is after; and zero if equal.\n */\nexport function lexicographicCompare(a: string, b: string): number {\n    // Dev note: this exists because I'm sad that you can use math operators on strings, so I've\n    // hidden the operation in this function.\n    if (a < b) {\n        return -1;\n    } else if (a > b) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/**\n * This function is similar to Object.assign() but it assigns recursively and\n * allows you to ignore nullish values from the source\n *\n * @returns the target object\n */\nexport function recursivelyAssign<T1 extends T2, T2 extends Record<string, any>>(\n    target: T1,\n    source: T2,\n    ignoreNullish = false,\n): T1 & T2 {\n    for (const [sourceKey, sourceValue] of Object.entries(source)) {\n        if (target[sourceKey] instanceof Object && sourceValue) {\n            recursivelyAssign(target[sourceKey], sourceValue);\n            continue;\n        }\n        if ((sourceValue !== null && sourceValue !== undefined) || !ignoreNullish) {\n            safeSet(target, sourceKey, sourceValue);\n            continue;\n        }\n    }\n    return target as T1 & T2;\n}\n\nfunction getContentTimestampWithFallback(event: MatrixEvent): number {\n    return M_TIMESTAMP.findIn<number>(event.getContent()) ?? -1;\n}\n\n/**\n * Sort events by their content m.ts property\n * Latest timestamp first\n */\nexport function sortEventsByLatestContentTimestamp(left: MatrixEvent, right: MatrixEvent): number {\n    return getContentTimestampWithFallback(right) - getContentTimestampWithFallback(left);\n}\n\nexport function isSupportedReceiptType(receiptType: string): boolean {\n    return [ReceiptType.Read, ReceiptType.ReadPrivate].includes(receiptType as ReceiptType);\n}\n\n/**\n * Determines whether two maps are equal.\n * @param eq - The equivalence relation to compare values by. Defaults to strict equality.\n */\nexport function mapsEqual<K, V>(x: Map<K, V>, y: Map<K, V>, eq = (v1: V, v2: V): boolean => v1 === v2): boolean {\n    if (x.size !== y.size) return false;\n    for (const [k, v1] of x) {\n        const v2 = y.get(k);\n        if (v2 === undefined || !eq(v1, v2)) return false;\n    }\n    return true;\n}\n\nfunction processMapToObjectValue(value: any): any {\n    if (value instanceof Map) {\n        // Value is a Map. Recursively map it to an object.\n        return recursiveMapToObject(value);\n    } else if (Array.isArray(value)) {\n        // Value is an Array. Recursively map the value (e.g. to cover Array of Arrays).\n        return value.map((v) => processMapToObjectValue(v));\n    } else {\n        return value;\n    }\n}\n\n/**\n * Recursively converts Maps to plain objects.\n * Also supports sub-lists of Maps.\n */\nexport function recursiveMapToObject(map: Map<any, any>): Record<any, any> {\n    const targetMap = new Map();\n\n    for (const [key, value] of map) {\n        targetMap.set(key, processMapToObjectValue(value));\n    }\n\n    return Object.fromEntries(targetMap.entries());\n}\n\nexport function unsafeProp<K extends keyof any | undefined>(prop: K): boolean {\n    return prop === \"__proto__\" || prop === \"prototype\" || prop === \"constructor\";\n}\n\nexport function safeSet<O extends Record<any, any>, K extends keyof O>(obj: O, prop: K, value: O[K]): void {\n    if (unsafeProp(prop)) {\n        throw new Error(\"Trying to modify prototype or constructor\");\n    }\n\n    obj[prop] = value;\n}\n\nexport function noUnsafeEventProps(event: Partial<IEvent>): boolean {\n    return !(unsafeProp(event.room_id) || unsafeProp(event.sender) || unsafeProp(event.event_id));\n}\n\nexport class MapWithDefault<K, V> extends Map<K, V> {\n    public constructor(private createDefault: () => V) {\n        super();\n    }\n\n    /**\n     * Returns the value if the key already exists.\n     * If not, it creates a new value under that key using the ctor callback and returns it.\n     */\n    public getOrCreate(key: K): V {\n        if (!this.has(key)) {\n            this.set(key, this.createDefault());\n        }\n\n        return this.get(key)!;\n    }\n}\n"],"mappings":"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","ignoreList":[]}