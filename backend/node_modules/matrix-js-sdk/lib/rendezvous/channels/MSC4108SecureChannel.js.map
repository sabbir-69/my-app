{"version":3,"file":"MSC4108SecureChannel.js","names":["Ecies","QrCodeData","QrCodeMode","ClientRendezvousFailureReason","MSC4108FailureReason","RendezvousError","logger","MSC4108SecureChannel","constructor","rendezvousSession","theirPublicKey","onFailure","_defineProperty","secureChannel","generateCode","mode","serverName","_this","_asyncToGenerator","url","Error","public_key","Reciprocate","undefined","toBytes","getCheckCode","_this$establishedChan","x","establishedChannel","check_code","Array","from","as_bytes","map","b","concat","join","connect","_this2","connected","result","establish_outbound_channel","channel","info","send","initial_message","ciphertext","receive","UnexpectedMessageReceived","candidateLoginOkMessage","decrypt","InsecureChannelDetected","loginInitiateMessage","message","candidateLoginInitiateMessage","establish_inbound_channel","loginOkMessage","encrypt","_this3","plaintext","_this4","secureSend","payload","_this5","stringifiedPayload","JSON","stringify","debug","type","secureReceive","_this6","json","parse","close","_this7","cancel","reason","_this8","_this8$onFailure","call","cancelled"],"sources":["../../../src/rendezvous/channels/MSC4108SecureChannel.ts"],"sourcesContent":["/*\nCopyright 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    type Curve25519PublicKey,\n    Ecies,\n    type EstablishedEcies,\n    QrCodeData,\n    QrCodeMode,\n} from \"@matrix-org/matrix-sdk-crypto-wasm\";\n\nimport {\n    ClientRendezvousFailureReason,\n    MSC4108FailureReason,\n    type MSC4108Payload,\n    RendezvousError,\n    type RendezvousFailureListener,\n} from \"../index.ts\";\nimport { type MSC4108RendezvousSession } from \"../transports/MSC4108RendezvousSession.ts\";\nimport { logger } from \"../../logger.ts\";\n\n/**\n * Prototype of the unstable [MSC4108](https://github.com/matrix-org/matrix-spec-proposals/pull/4108)\n * secure rendezvous session protocol.\n * @experimental Note that this is UNSTABLE and may have breaking changes without notice.\n * Imports @matrix-org/matrix-sdk-crypto-wasm so should be async-imported to avoid bundling the WASM into the main bundle.\n */\nexport class MSC4108SecureChannel {\n    private readonly secureChannel: Ecies;\n    private establishedChannel?: EstablishedEcies;\n    private connected = false;\n\n    public constructor(\n        private rendezvousSession: MSC4108RendezvousSession,\n        private theirPublicKey?: Curve25519PublicKey,\n        public onFailure?: RendezvousFailureListener,\n    ) {\n        this.secureChannel = new Ecies();\n    }\n\n    /**\n     * Generate a QR code for the current session.\n     * @param mode the mode to generate the QR code in, either `Login` or `Reciprocate`.\n     * @param serverName the name of the homeserver to connect to, as defined by server discovery in the spec, required for `Reciprocate` mode.\n     */\n    public async generateCode(mode: QrCodeMode.Login): Promise<Uint8Array>;\n    public async generateCode(mode: QrCodeMode.Reciprocate, serverName: string): Promise<Uint8Array>;\n    public async generateCode(mode: QrCodeMode, serverName?: string): Promise<Uint8Array> {\n        const { url } = this.rendezvousSession;\n\n        if (!url) {\n            throw new Error(\"No rendezvous session URL\");\n        }\n\n        return new QrCodeData(\n            this.secureChannel.public_key(),\n            url,\n            mode === QrCodeMode.Reciprocate ? serverName : undefined,\n        ).toBytes();\n    }\n\n    /**\n     * Returns the check code for the secure channel or undefined if not generated yet.\n     */\n    public getCheckCode(): string | undefined {\n        const x = this.establishedChannel?.check_code();\n\n        if (!x) {\n            return undefined;\n        }\n        return Array.from(x.as_bytes())\n            .map((b) => `${b % 10}`)\n            .join(\"\");\n    }\n\n    /**\n     * Connects and establishes a secure channel with the other device.\n     */\n    public async connect(): Promise<void> {\n        if (this.connected) {\n            throw new Error(\"Channel already connected\");\n        }\n\n        if (this.theirPublicKey) {\n            // We are the scanning device\n            const result = this.secureChannel.establish_outbound_channel(\n                this.theirPublicKey,\n                \"MATRIX_QR_CODE_LOGIN_INITIATE\",\n            );\n            this.establishedChannel = result.channel;\n\n            /*\n             Secure Channel step 4. Device S sends the initial message\n\n             Nonce := 0\n             SH := ECDH(Ss, Gp)\n             EncKey := HKDF_SHA256(SH, \"MATRIX_QR_CODE_LOGIN|\" || Gp || \"|\" || Sp, 0, 32)\n             TaggedCiphertext := ChaCha20Poly1305_Encrypt(EncKey, Nonce, \"MATRIX_QR_CODE_LOGIN_INITIATE\")\n             Nonce := Nonce + 2\n             LoginInitiateMessage := UnpaddedBase64(TaggedCiphertext) || \"|\" || UnpaddedBase64(Sp)\n             */\n            {\n                logger.info(\"Sending LoginInitiateMessage\");\n                await this.rendezvousSession.send(result.initial_message);\n            }\n\n            /*\n            Secure Channel step 6. Verification by Device S\n\n            Nonce_G := 1\n            (TaggedCiphertext, Sp) := Unpack(Message)\n            Plaintext := ChaCha20Poly1305_Decrypt(EncKey, Nonce_G, TaggedCiphertext)\n            Nonce_G := Nonce_G + 2\n\n            unless Plaintext == \"MATRIX_QR_CODE_LOGIN_OK\":\n                FAIL\n             */\n            {\n                logger.info(\"Waiting for LoginOkMessage\");\n                const ciphertext = await this.rendezvousSession.receive();\n\n                if (!ciphertext) {\n                    throw new RendezvousError(\n                        \"No response from other device\",\n                        MSC4108FailureReason.UnexpectedMessageReceived,\n                    );\n                }\n                const candidateLoginOkMessage = await this.decrypt(ciphertext);\n\n                if (candidateLoginOkMessage !== \"MATRIX_QR_CODE_LOGIN_OK\") {\n                    throw new RendezvousError(\n                        \"Invalid response from other device\",\n                        ClientRendezvousFailureReason.InsecureChannelDetected,\n                    );\n                }\n\n                // Step 6 is now complete. We trust the channel\n            }\n        } else {\n            /*\n            Secure Channel step 5. Device G confirms\n\n            Nonce_S := 0\n            (TaggedCiphertext, Sp) := Unpack(LoginInitiateMessage)\n            SH := ECDH(Gs, Sp)\n            EncKey := HKDF_SHA256(SH, \"MATRIX_QR_CODE_LOGIN|\" || Gp || \"|\" || Sp, 0, 32)\n            Plaintext := ChaCha20Poly1305_Decrypt(EncKey, Nonce_S, TaggedCiphertext)\n            Nonce_S := Nonce_S + 2\n             */\n            // wait for the other side to send us their public key\n            logger.info(\"Waiting for LoginInitiateMessage\");\n            const loginInitiateMessage = await this.rendezvousSession.receive();\n            if (!loginInitiateMessage) {\n                throw new Error(\"No response from other device\");\n            }\n\n            const { channel, message: candidateLoginInitiateMessage } =\n                this.secureChannel.establish_inbound_channel(loginInitiateMessage);\n            this.establishedChannel = channel;\n\n            if (candidateLoginInitiateMessage !== \"MATRIX_QR_CODE_LOGIN_INITIATE\") {\n                throw new RendezvousError(\n                    \"Invalid response from other device\",\n                    ClientRendezvousFailureReason.InsecureChannelDetected,\n                );\n            }\n            logger.info(\"LoginInitiateMessage received\");\n\n            logger.info(\"Sending LoginOkMessage\");\n            const loginOkMessage = await this.encrypt(\"MATRIX_QR_CODE_LOGIN_OK\");\n            await this.rendezvousSession.send(loginOkMessage);\n\n            // Step 5 is complete. We don't yet trust the channel\n\n            // next step will be for the user to confirm the check code on the other device\n        }\n\n        this.connected = true;\n    }\n\n    private async decrypt(ciphertext: string): Promise<string> {\n        if (!this.establishedChannel) {\n            throw new Error(\"Channel closed\");\n        }\n\n        return this.establishedChannel.decrypt(ciphertext);\n    }\n\n    private async encrypt(plaintext: string): Promise<string> {\n        if (!this.establishedChannel) {\n            throw new Error(\"Channel closed\");\n        }\n\n        return this.establishedChannel.encrypt(plaintext);\n    }\n\n    /**\n     * Sends a payload securely to the other device.\n     * @param payload the payload to encrypt and send\n     */\n    public async secureSend<T extends MSC4108Payload>(payload: T): Promise<void> {\n        if (!this.connected) {\n            throw new Error(\"Channel closed\");\n        }\n\n        const stringifiedPayload = JSON.stringify(payload);\n        logger.debug(`=> {\"type\": ${JSON.stringify(payload.type)}, ...}`);\n\n        await this.rendezvousSession.send(await this.encrypt(stringifiedPayload));\n    }\n\n    /**\n     * Receives an encrypted payload from the other device and decrypts it.\n     */\n    public async secureReceive<T extends MSC4108Payload>(): Promise<Partial<T> | undefined> {\n        if (!this.establishedChannel) {\n            throw new Error(\"Channel closed\");\n        }\n\n        const ciphertext = await this.rendezvousSession.receive();\n        if (!ciphertext) {\n            return undefined;\n        }\n        const plaintext = await this.decrypt(ciphertext);\n        const json = JSON.parse(plaintext);\n\n        logger.debug(`<= {\"type\": ${JSON.stringify(json.type)}, ...}`);\n        return json as Partial<T> | undefined;\n    }\n\n    /**\n     * Closes the secure channel.\n     */\n    public async close(): Promise<void> {\n        await this.rendezvousSession.close();\n    }\n\n    /**\n     * Cancels the secure channel.\n     * @param reason the reason for the cancellation\n     */\n    public async cancel(reason: MSC4108FailureReason | ClientRendezvousFailureReason): Promise<void> {\n        try {\n            await this.rendezvousSession.cancel(reason);\n            this.onFailure?.(reason);\n        } finally {\n            await this.close();\n        }\n    }\n\n    /**\n     * Returns whether the rendezvous session has been cancelled.\n     */\n    public get cancelled(): boolean {\n        return this.rendezvousSession.cancelled;\n    }\n}\n"],"mappings":"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","ignoreList":[]}