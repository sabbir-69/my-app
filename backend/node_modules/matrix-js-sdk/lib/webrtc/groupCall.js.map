{"version":3,"file":"groupCall.js","names":["TypedEventEmitter","CallFeed","SPEAKING_THRESHOLD","CallErrorCode","CallEvent","CallState","genCallID","setTracksEnabled","createNewMatrixCall","CallError","RoomStateEvent","logger","ReEmitter","SDPStreamMetadataPurpose","EventType","CallEventHandlerEvent","GroupCallEventHandlerEvent","mapsEqual","GroupCallStats","StatsReport","SummaryStatsReportGatherer","CallFeedStatsReporter","KnownMembership","GroupCallIntent","GroupCallType","GroupCallTerminationReason","GroupCallEvent","GroupCallStatsReportEvent","GroupCallErrorCode","GroupCallError","Error","constructor","code","msg","err","_defineProperty","GroupCallUnknownDeviceError","userId","UnknownDevice","OtherUserSpeakingError","GroupCallState","DEVICE_TIMEOUT","getCallUserId","call","_call$getOpponentMemb","getOpponentMember","invitee","GroupCall","client","room","type","isPtt","intent","groupCallId","dataChannelsEnabled","dataChannelOptions","isCallWithoutVideoAndAudio","_room$currentState$ge","_room$currentState$ge2","useLivekit","arguments","length","undefined","livekitServiceURL","Map","report","emit","ConnectionStats","ByteSentStats","extendSummaryReport","participants","SummaryStats","localCallFeed","expandCallFeedReport","callFeeds","forEachCall","callId","getFeeds","forEach","f","push","CallFeedStats","LocalCallFeedUninitialized","newCall","_newCall$getOpponentM","_this$calls$get","roomId","state","Ringing","warn","concat","log","reject","opponentUserId","info","deviceMap","calls","get","prevCall","getOpponentDeviceId","hangup","Replaced","set","initCall","feeds","getLocalFeeds","map","feed","clone","callExpected","stream","getAudioTracks","getVideoTracks","answerWithCallFeeds","CallsChanged","needsRetry","participantMap","callMap","retriesMap","retryCallCounts","deviceId","participant","_retriesMap$get","_retriesMap","retries","getOpponentSessionId","sessionId","wantsOutgoingCall","placeOutgoingCalls","opponentMemberId","opponentDeviceId","currentUserMediaFeed","getUserMediaFeed","remoteUsermediaFeed","remoteFeedChanged","currentCallForUserDevice","addUserMediaFeed","replaceUserMediaFeed","removeUserMediaFeed","currentScreenshareFeed","getScreenshareFeed","remoteScreensharingFeed","remoteScreenshareFeedChanged","addScreenshareFeed","replaceScreenshareFeed","removeScreenshareFeed","_oldState","_call$getOpponentMemb2","Ended","audioMuted","isAudioMuted","localUsermediaStream","isMicrophoneMuted","setMicrophoneMuted","videoMuted","isVideoMuted","isLocalVideoMuted","setLocalVideoMuted","Connected","delete","size","_call$getOpponentMemb3","_call$getOpponentMemb4","hangupReason","getMember","disposeCall","topAvg","nextActiveSpeaker","callFeed","userMediaFeeds","isLocal","total","speakingVolumeSamples","reduce","acc","volume","Math","max","avg","activeSpeaker","ActiveSpeakerChanged","updateParticipants","expected","Entered","newState","oldState","updateMemberState","catch","e","error","reEmitter","_livekitServiceURL","creationTs","currentState","getStateEvents","GroupCallPrefix","getTs","on","Update","onRoomState","ParticipantsChanged","onParticipantsChanged","GroupCallStateChanged","onStateChanged","LocalScreenshareStateChanged","onLocalFeedsChanged","allowCallWithoutVideoAndAudio","create","_this","_asyncToGenerator","Date","now","groupCallEventHandler","groupCalls","Outgoing","sendCallStateEvent","_this2","groupCallState","sendStateEvent","updateLivekitServiceURL","newURL","_state","value","prevValue","_participants","participantStateEqual","x","y","screensharing","deviceMapsEqual","_creationTs","enteredViaAnotherSession","_enteredViaAnotherSession","values","localScreenshareFeed","hasLocalParticipant","_this$participants$ge","_this$participants$ge2","getUserId","has","getDeviceId","_this$participants$ge3","member","initLocalCallFeed","_this3","InitializingLocalCallFeed","initCallFeedPromise","initLocalCallFeedInternal","_this4","getMediaHandler","getUserMediaStream","Video","MediaStream","stopUserMediaStream","purpose","Usermedia","initWithAudioMuted","initWithVideoMuted","LocalCallFeedInitialized","updateLocalUsermediaStream","_this5","oldStream","setNewStream","micShouldBeMuted","vidShouldBeMuted","id","enter","_this6","Incoming","onIncomingCall","callEventHandler","retryCallLoopInterval","setInterval","onRetryCallLoop","retryCallInterval","onActiveSpeakerLoop","activeSpeakerLoopInterval","activeSpeakerInterval","dispose","_this$stats","stopScreensharingStream","localDesktopCapturerSourceId","stopAllStreams","transmitTimer","clearTimeout","clearInterval","participantsExpirationTimer","UserHangup","clear","removeListener","stats","stop","leave","terminate","_arguments","_this7","emitStateEvent","off","existingStateEvent","_objectSpread","getContent","CallEnded","muted","_this8","hasAudioDevice","sendUpdatesBefore","setTimeout","pttMaxTransmitTime","_call$localUsermediaF","localUsermediaFeed","setAudioVideoMuted","sendUpdates","_ref","updates","sendMetadataUpdate","Promise","all","apply","hasPermission","checkAudioPermissionIfNecessary","LocalMuteStateChanged","_this9","hasAudioTrack","getTracks","_unused","_this0","hasVideoDevice","_unused2","setScreensharingEnabled","enabled","_arguments2","_this1","opts","isScreensharing","getScreensharingStream","_loop","track","onTrackEnded","removeEventListener","addEventListener","desktopCapturerSourceId","Screenshare","pushLocalFeed","throwOnFail","NoUserMedia","localScreensharingFeed","removeLocalFeed","localUserId","localDeviceId","_this10","callsChanged","_loop2","_userId2","_this10$calls$get","_loop3","debug","NewSession","opponentSessionId","placeCallWithCallFeeds","then","createDataChannel","PlaceCallFailed","SignallingFailed","getMemberStateEvents","GroupCallMemberPrefix","onCallFeedsChanged","onCallStateChanged","onCallHangup","onCallReplaced","callHandlers","FeedsChanged","State","Hangup","reEmit","Object","initStats","getGroupCallStats","usermediaFeed","screenshareFeed","find","measureVolumeActivity","UserMediaFeedsChanged","existingFeed","replacementFeed","feedIndex","findIndex","splice","screenshareFeeds","ScreenshareFeedsChanged","localMember","getSafeUserId","entered","nextExpiration","Infinity","getStateKey","content","Array","isArray","devices","validDevices","filter","d","device_id","session_id","expires_ts","membership","Join","some","getSessionId","updateDevices","fn","_arguments3","_this11","_event$getContent","keepAlive","event","otherCalls","c","newDevices","newCalls","newContent","addDeviceToMemberState","_this12","_this13","resendMemberStateTimer","cleanMemberState","_this14","myDevices","getDevices","device","last_seen_ts","userID","statsCollectIntervalTime","reports","CONNECTION_STATS","onConnectionStats","BYTE_SENT_STATS","onByteSentStats","SUMMARY_STATS","onSummaryStats","CALL_FEED_REPORT","onCallFeedReport","setGroupCallStatsInterval","interval","start"],"sources":["../../src/webrtc/groupCall.ts"],"sourcesContent":["import { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { CallFeed, SPEAKING_THRESHOLD } from \"./callFeed.ts\";\nimport { type MatrixClient, type IMyDevice } from \"../client.ts\";\nimport {\n    CallErrorCode,\n    CallEvent,\n    type CallEventHandlerMap,\n    CallState,\n    genCallID,\n    type MatrixCall,\n    setTracksEnabled,\n    createNewMatrixCall,\n    CallError,\n} from \"./call.ts\";\nimport { type RoomMember } from \"../models/room-member.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { RoomStateEvent } from \"../models/room-state.ts\";\nimport { logger } from \"../logger.ts\";\nimport { ReEmitter } from \"../ReEmitter.ts\";\nimport { SDPStreamMetadataPurpose } from \"./callEventTypes.ts\";\nimport { type MatrixEvent } from \"../models/event.ts\";\nimport { EventType } from \"../@types/event.ts\";\nimport { CallEventHandlerEvent } from \"./callEventHandler.ts\";\nimport { GroupCallEventHandlerEvent } from \"./groupCallEventHandler.ts\";\nimport { type IScreensharingOpts } from \"./mediaHandler.ts\";\nimport { mapsEqual } from \"../utils.ts\";\nimport { GroupCallStats } from \"./stats/groupCallStats.ts\";\nimport {\n    type ByteSentStatsReport,\n    type CallFeedReport,\n    type ConnectionStatsReport,\n    StatsReport,\n    type SummaryStatsReport,\n} from \"./stats/statsReport.ts\";\nimport { SummaryStatsReportGatherer } from \"./stats/summaryStatsReportGatherer.ts\";\nimport { CallFeedStatsReporter } from \"./stats/callFeedStatsReporter.ts\";\nimport { KnownMembership } from \"../@types/membership.ts\";\n\nexport enum GroupCallIntent {\n    Ring = \"m.ring\",\n    Prompt = \"m.prompt\",\n    Room = \"m.room\",\n}\n\nexport enum GroupCallType {\n    Video = \"m.video\",\n    Voice = \"m.voice\",\n}\n\nexport enum GroupCallTerminationReason {\n    CallEnded = \"call_ended\",\n}\n\nexport type CallsByUserAndDevice = Map<string, Map<string, MatrixCall>>;\n\n/**\n * Because event names are just strings, they do need\n * to be unique over all event types of event emitter.\n * Some objects could emit more then one set of events.\n */\nexport enum GroupCallEvent {\n    GroupCallStateChanged = \"group_call_state_changed\",\n    ActiveSpeakerChanged = \"active_speaker_changed\",\n    CallsChanged = \"calls_changed\",\n    UserMediaFeedsChanged = \"user_media_feeds_changed\",\n    ScreenshareFeedsChanged = \"screenshare_feeds_changed\",\n    LocalScreenshareStateChanged = \"local_screenshare_state_changed\",\n    LocalMuteStateChanged = \"local_mute_state_changed\",\n    ParticipantsChanged = \"participants_changed\",\n    Error = \"group_call_error\",\n}\n\nexport type GroupCallEventHandlerMap = {\n    [GroupCallEvent.GroupCallStateChanged]: (newState: GroupCallState, oldState: GroupCallState) => void;\n    [GroupCallEvent.ActiveSpeakerChanged]: (activeSpeaker: CallFeed | undefined) => void;\n    [GroupCallEvent.CallsChanged]: (calls: CallsByUserAndDevice) => void;\n    [GroupCallEvent.UserMediaFeedsChanged]: (feeds: CallFeed[]) => void;\n    [GroupCallEvent.ScreenshareFeedsChanged]: (feeds: CallFeed[]) => void;\n    [GroupCallEvent.LocalScreenshareStateChanged]: (\n        isScreensharing: boolean,\n        feed?: CallFeed,\n        sourceId?: string,\n    ) => void;\n    [GroupCallEvent.LocalMuteStateChanged]: (audioMuted: boolean, videoMuted: boolean) => void;\n    [GroupCallEvent.ParticipantsChanged]: (participants: Map<RoomMember, Map<string, ParticipantState>>) => void;\n    /**\n     * Fires whenever an error occurs when call.js encounters an issue with setting up the call.\n     * <p>\n     * The error given will have a code equal to either `MatrixCall.ERR_LOCAL_OFFER_FAILED` or\n     * `MatrixCall.ERR_NO_USER_MEDIA`. `ERR_LOCAL_OFFER_FAILED` is emitted when the local client\n     * fails to create an offer. `ERR_NO_USER_MEDIA` is emitted when the user has denied access\n     * to their audio/video hardware.\n     * @param error - The error raised by MatrixCall.\n     * @example\n     * ```\n     * matrixCall.on(\"error\", function(err){\n     *   console.error(err.code, err);\n     * });\n     * ```\n     */\n    [GroupCallEvent.Error]: (error: GroupCallError) => void;\n};\n\nexport enum GroupCallStatsReportEvent {\n    ConnectionStats = \"GroupCall.connection_stats\",\n    ByteSentStats = \"GroupCall.byte_sent_stats\",\n    SummaryStats = \"GroupCall.summary_stats\",\n    CallFeedStats = \"GroupCall.call_feed_stats\",\n}\n\n/**\n * The final report-events that get consumed by client.\n */\nexport type GroupCallStatsReportEventHandlerMap = {\n    [GroupCallStatsReportEvent.ConnectionStats]: (report: GroupCallStatsReport<ConnectionStatsReport>) => void;\n    [GroupCallStatsReportEvent.ByteSentStats]: (report: GroupCallStatsReport<ByteSentStatsReport>) => void;\n    [GroupCallStatsReportEvent.SummaryStats]: (report: GroupCallStatsReport<SummaryStatsReport>) => void;\n    [GroupCallStatsReportEvent.CallFeedStats]: (report: GroupCallStatsReport<CallFeedReport>) => void;\n};\n\nexport enum GroupCallErrorCode {\n    NoUserMedia = \"no_user_media\",\n    UnknownDevice = \"unknown_device\",\n    PlaceCallFailed = \"place_call_failed\",\n}\n\nexport interface GroupCallStatsReport<\n    T extends ConnectionStatsReport | ByteSentStatsReport | SummaryStatsReport | CallFeedReport,\n> {\n    report: T;\n}\n\nexport class GroupCallError extends Error {\n    public code: string;\n\n    public constructor(code: GroupCallErrorCode, msg: string, err?: Error) {\n        // Still don't think there's any way to have proper nested errors\n        if (err) {\n            super(msg + \": \" + err);\n        } else {\n            super(msg);\n        }\n\n        this.code = code;\n    }\n}\n\nexport class GroupCallUnknownDeviceError extends GroupCallError {\n    public constructor(public userId: string) {\n        super(GroupCallErrorCode.UnknownDevice, \"No device found for \" + userId);\n    }\n}\n\nexport class OtherUserSpeakingError extends Error {\n    public constructor() {\n        super(\"Cannot unmute: another user is speaking\");\n    }\n}\n\nexport interface IGroupCallDataChannelOptions {\n    ordered: boolean;\n    maxPacketLifeTime: number;\n    maxRetransmits: number;\n    protocol: string;\n}\n\nexport interface IGroupCallRoomState {\n    \"m.intent\": GroupCallIntent;\n    \"m.type\": GroupCallType;\n    \"m.terminated\"?: GroupCallTerminationReason;\n    \"io.element.ptt\"?: boolean;\n    // TODO: Specify data-channels\n    \"dataChannelsEnabled\"?: boolean;\n    \"dataChannelOptions\"?: IGroupCallDataChannelOptions;\n\n    \"io.element.livekit_service_url\"?: string;\n}\n\nexport interface IGroupCallRoomMemberFeed {\n    purpose: SDPStreamMetadataPurpose;\n}\n\nexport interface IGroupCallRoomMemberDevice {\n    device_id: string;\n    session_id: string;\n    expires_ts: number;\n    feeds: IGroupCallRoomMemberFeed[];\n}\n\nexport interface IGroupCallRoomMemberCallState {\n    \"m.call_id\": string;\n    \"m.foci\"?: string[];\n    \"m.devices\": IGroupCallRoomMemberDevice[];\n}\n\nexport interface IGroupCallRoomMemberState {\n    \"m.calls\": IGroupCallRoomMemberCallState[];\n}\n\nexport enum GroupCallState {\n    LocalCallFeedUninitialized = \"local_call_feed_uninitialized\",\n    InitializingLocalCallFeed = \"initializing_local_call_feed\",\n    LocalCallFeedInitialized = \"local_call_feed_initialized\",\n    Entered = \"entered\",\n    Ended = \"ended\",\n}\n\nexport interface ParticipantState {\n    sessionId: string;\n    screensharing: boolean;\n}\n\ninterface ICallHandlers {\n    onCallFeedsChanged: (feeds: CallFeed[]) => void;\n    onCallStateChanged: (state: CallState, oldState: CallState | undefined) => void;\n    onCallHangup: (call: MatrixCall) => void;\n    onCallReplaced: (newCall: MatrixCall) => void;\n}\n\nconst DEVICE_TIMEOUT = 1000 * 60 * 60; // 1 hour\n\nfunction getCallUserId(call: MatrixCall): string | null {\n    return call.getOpponentMember()?.userId || call.invitee || null;\n}\n\nexport class GroupCall extends TypedEventEmitter<\n    GroupCallEvent | CallEvent | GroupCallStatsReportEvent,\n    GroupCallEventHandlerMap & CallEventHandlerMap & GroupCallStatsReportEventHandlerMap\n> {\n    // Config\n    public activeSpeakerInterval = 1000;\n    public retryCallInterval = 5000;\n    public participantTimeout = 1000 * 15;\n    public pttMaxTransmitTime = 1000 * 20;\n\n    public activeSpeaker?: CallFeed;\n    public localCallFeed?: CallFeed;\n    public localScreenshareFeed?: CallFeed;\n    public localDesktopCapturerSourceId?: string;\n    public readonly userMediaFeeds: CallFeed[] = [];\n    public readonly screenshareFeeds: CallFeed[] = [];\n    public groupCallId: string;\n    public readonly allowCallWithoutVideoAndAudio: boolean;\n\n    private readonly calls = new Map<string, Map<string, MatrixCall>>(); // user_id -> device_id -> MatrixCall\n    private callHandlers = new Map<string, Map<string, ICallHandlers>>(); // user_id -> device_id -> ICallHandlers\n    private activeSpeakerLoopInterval?: ReturnType<typeof setTimeout>;\n    private retryCallLoopInterval?: ReturnType<typeof setTimeout>;\n    private retryCallCounts: Map<string, Map<string, number>> = new Map(); // user_id -> device_id -> count\n    private reEmitter: ReEmitter;\n    private transmitTimer: ReturnType<typeof setTimeout> | null = null;\n    private participantsExpirationTimer: ReturnType<typeof setTimeout> | null = null;\n    private resendMemberStateTimer: ReturnType<typeof setInterval> | null = null;\n    private initWithAudioMuted = false;\n    private initWithVideoMuted = false;\n    private initCallFeedPromise?: Promise<void>;\n    private _livekitServiceURL?: string;\n\n    private stats: GroupCallStats | undefined;\n    /**\n     * Configure default webrtc stats collection interval in ms\n     * Disable collecting webrtc stats by setting interval to 0\n     */\n    private statsCollectIntervalTime = 0;\n\n    public constructor(\n        private client: MatrixClient,\n        public room: Room,\n        public type: GroupCallType,\n        public isPtt: boolean,\n        public intent: GroupCallIntent,\n        groupCallId?: string,\n        private dataChannelsEnabled?: boolean,\n        private dataChannelOptions?: IGroupCallDataChannelOptions,\n        isCallWithoutVideoAndAudio?: boolean,\n        // this tells the js-sdk not to actually establish any calls to exchange media and just to\n        // create the group call signaling events, with the intention that the actual media will be\n        // handled using livekit. The js-sdk doesn't contain any code to do the actual livekit call though.\n        private useLivekit = false,\n        livekitServiceURL?: string,\n    ) {\n        super();\n        this.reEmitter = new ReEmitter(this);\n        this.groupCallId = groupCallId ?? genCallID();\n        this._livekitServiceURL = livekitServiceURL;\n        this.creationTs =\n            room.currentState.getStateEvents(EventType.GroupCallPrefix, this.groupCallId)?.getTs() ?? null;\n        this.updateParticipants();\n\n        room.on(RoomStateEvent.Update, this.onRoomState);\n        this.on(GroupCallEvent.ParticipantsChanged, this.onParticipantsChanged);\n        this.on(GroupCallEvent.GroupCallStateChanged, this.onStateChanged);\n        this.on(GroupCallEvent.LocalScreenshareStateChanged, this.onLocalFeedsChanged);\n        this.allowCallWithoutVideoAndAudio = !!isCallWithoutVideoAndAudio;\n    }\n\n    private onConnectionStats = (report: ConnectionStatsReport): void => {\n        // Final emit of the summary event, to be consumed by the client\n        this.emit(GroupCallStatsReportEvent.ConnectionStats, { report });\n    };\n\n    private onByteSentStats = (report: ByteSentStatsReport): void => {\n        // Final emit of the summary event, to be consumed by the client\n        this.emit(GroupCallStatsReportEvent.ByteSentStats, { report });\n    };\n\n    private onSummaryStats = (report: SummaryStatsReport): void => {\n        SummaryStatsReportGatherer.extendSummaryReport(report, this.participants);\n        // Final emit of the summary event, to be consumed by the client\n        this.emit(GroupCallStatsReportEvent.SummaryStats, { report });\n    };\n\n    private onCallFeedReport = (report: CallFeedReport): void => {\n        if (this.localCallFeed) {\n            report = CallFeedStatsReporter.expandCallFeedReport(report, [this.localCallFeed], \"from-local-feed\");\n        }\n\n        const callFeeds: CallFeed[] = [];\n        this.forEachCall((call) => {\n            if (call.callId === report.callId) {\n                call.getFeeds().forEach((f) => callFeeds.push(f));\n            }\n        });\n\n        report = CallFeedStatsReporter.expandCallFeedReport(report, callFeeds, \"from-call-feed\");\n        this.emit(GroupCallStatsReportEvent.CallFeedStats, { report });\n    };\n\n    public async create(): Promise<GroupCall> {\n        this.creationTs = Date.now();\n        this.client.groupCallEventHandler!.groupCalls.set(this.room.roomId, this);\n        this.client.emit(GroupCallEventHandlerEvent.Outgoing, this);\n\n        await this.sendCallStateEvent();\n\n        return this;\n    }\n\n    private async sendCallStateEvent(): Promise<void> {\n        const groupCallState: IGroupCallRoomState = {\n            \"m.intent\": this.intent,\n            \"m.type\": this.type,\n            \"io.element.ptt\": this.isPtt,\n            // TODO: Specify data-channels better\n            \"dataChannelsEnabled\": this.dataChannelsEnabled,\n            \"dataChannelOptions\": this.dataChannelsEnabled ? this.dataChannelOptions : undefined,\n        };\n        if (this.livekitServiceURL) {\n            groupCallState[\"io.element.livekit_service_url\"] = this.livekitServiceURL;\n        }\n\n        await this.client.sendStateEvent(this.room.roomId, EventType.GroupCallPrefix, groupCallState, this.groupCallId);\n    }\n\n    public get livekitServiceURL(): string | undefined {\n        return this._livekitServiceURL;\n    }\n\n    public updateLivekitServiceURL(newURL: string): Promise<void> {\n        this._livekitServiceURL = newURL;\n        return this.sendCallStateEvent();\n    }\n\n    private _state = GroupCallState.LocalCallFeedUninitialized;\n\n    /**\n     * The group call's state.\n     */\n    public get state(): GroupCallState {\n        return this._state;\n    }\n\n    private set state(value: GroupCallState) {\n        const prevValue = this._state;\n        if (value !== prevValue) {\n            this._state = value;\n            this.emit(GroupCallEvent.GroupCallStateChanged, value, prevValue);\n        }\n    }\n\n    private _participants = new Map<RoomMember, Map<string, ParticipantState>>();\n\n    /**\n     * The current participants in the call, as a map from members to device IDs\n     * to participant info.\n     */\n    public get participants(): Map<RoomMember, Map<string, ParticipantState>> {\n        return this._participants;\n    }\n\n    private set participants(value: Map<RoomMember, Map<string, ParticipantState>>) {\n        const prevValue = this._participants;\n        const participantStateEqual = (x: ParticipantState, y: ParticipantState): boolean =>\n            x.sessionId === y.sessionId && x.screensharing === y.screensharing;\n        const deviceMapsEqual = (x: Map<string, ParticipantState>, y: Map<string, ParticipantState>): boolean =>\n            mapsEqual(x, y, participantStateEqual);\n\n        // Only update if the map actually changed\n        if (!mapsEqual(value, prevValue, deviceMapsEqual)) {\n            this._participants = value;\n            this.emit(GroupCallEvent.ParticipantsChanged, value);\n        }\n    }\n\n    private _creationTs: number | null = null;\n\n    /**\n     * The timestamp at which the call was created, or null if it has not yet\n     * been created.\n     */\n    public get creationTs(): number | null {\n        return this._creationTs;\n    }\n\n    private set creationTs(value: number | null) {\n        this._creationTs = value;\n    }\n\n    private _enteredViaAnotherSession = false;\n\n    /**\n     * Whether the local device has entered this call via another session, such\n     * as a widget.\n     */\n    public get enteredViaAnotherSession(): boolean {\n        return this._enteredViaAnotherSession;\n    }\n\n    public set enteredViaAnotherSession(value: boolean) {\n        this._enteredViaAnotherSession = value;\n        this.updateParticipants();\n    }\n\n    /**\n     * Executes the given callback on all calls in this group call.\n     * @param f - The callback.\n     */\n    public forEachCall(f: (call: MatrixCall) => void): void {\n        for (const deviceMap of this.calls.values()) {\n            for (const call of deviceMap.values()) f(call);\n        }\n    }\n\n    public getLocalFeeds(): CallFeed[] {\n        const feeds: CallFeed[] = [];\n\n        if (this.localCallFeed) feeds.push(this.localCallFeed);\n        if (this.localScreenshareFeed) feeds.push(this.localScreenshareFeed);\n\n        return feeds;\n    }\n\n    public hasLocalParticipant(): boolean {\n        return (\n            this.participants.get(this.room.getMember(this.client.getUserId()!)!)?.has(this.client.getDeviceId()!) ??\n            false\n        );\n    }\n\n    /**\n     * Determines whether the given call is one that we were expecting to exist\n     * given our knowledge of who is participating in the group call.\n     */\n    private callExpected(call: MatrixCall): boolean {\n        const userId = getCallUserId(call);\n        const member = userId === null ? null : this.room.getMember(userId);\n        const deviceId = call.getOpponentDeviceId();\n        return member !== null && deviceId !== undefined && this.participants.get(member)?.get(deviceId) !== undefined;\n    }\n\n    public async initLocalCallFeed(): Promise<void> {\n        if (this.useLivekit) {\n            logger.info(\"Livekit group call: not starting local call feed.\");\n            return;\n        }\n\n        if (this.state !== GroupCallState.LocalCallFeedUninitialized) {\n            throw new Error(`Cannot initialize local call feed in the \"${this.state}\" state.`);\n        }\n        this.state = GroupCallState.InitializingLocalCallFeed;\n\n        // wraps the real method to serialise calls, because we don't want to try starting\n        // multiple call feeds at once\n        if (this.initCallFeedPromise) return this.initCallFeedPromise;\n\n        try {\n            this.initCallFeedPromise = this.initLocalCallFeedInternal();\n            await this.initCallFeedPromise;\n        } finally {\n            this.initCallFeedPromise = undefined;\n        }\n    }\n\n    private async initLocalCallFeedInternal(): Promise<void> {\n        logger.log(`GroupCall ${this.groupCallId} initLocalCallFeedInternal() running`);\n\n        let stream: MediaStream;\n\n        try {\n            stream = await this.client.getMediaHandler().getUserMediaStream(true, this.type === GroupCallType.Video);\n        } catch (error) {\n            // If is allowed to join a call without a media stream, then we\n            // don't throw an error here. But we need an empty Local Feed to establish\n            // a connection later.\n            if (this.allowCallWithoutVideoAndAudio) {\n                stream = new MediaStream();\n            } else {\n                this.state = GroupCallState.LocalCallFeedUninitialized;\n                throw error;\n            }\n        }\n\n        // The call could've been disposed while we were waiting, and could\n        // also have been started back up again (hello, React 18) so if we're\n        // still in this 'initializing' state, carry on, otherwise bail.\n        if (this._state !== GroupCallState.InitializingLocalCallFeed) {\n            this.client.getMediaHandler().stopUserMediaStream(stream);\n            throw new Error(\"Group call disposed while gathering media stream\");\n        }\n\n        const callFeed = new CallFeed({\n            client: this.client,\n            roomId: this.room.roomId,\n            userId: this.client.getUserId()!,\n            deviceId: this.client.getDeviceId()!,\n            stream,\n            purpose: SDPStreamMetadataPurpose.Usermedia,\n            audioMuted: this.initWithAudioMuted || stream.getAudioTracks().length === 0 || this.isPtt,\n            videoMuted: this.initWithVideoMuted || stream.getVideoTracks().length === 0,\n        });\n\n        setTracksEnabled(stream.getAudioTracks(), !callFeed.isAudioMuted());\n        setTracksEnabled(stream.getVideoTracks(), !callFeed.isVideoMuted());\n\n        this.localCallFeed = callFeed;\n        this.addUserMediaFeed(callFeed);\n\n        this.state = GroupCallState.LocalCallFeedInitialized;\n    }\n\n    public async updateLocalUsermediaStream(stream: MediaStream): Promise<void> {\n        if (this.localCallFeed) {\n            const oldStream = this.localCallFeed.stream;\n            this.localCallFeed.setNewStream(stream);\n            const micShouldBeMuted = this.localCallFeed.isAudioMuted();\n            const vidShouldBeMuted = this.localCallFeed.isVideoMuted();\n            logger.log(\n                `GroupCall ${this.groupCallId} updateLocalUsermediaStream() (oldStreamId=${oldStream.id}, newStreamId=${stream.id}, micShouldBeMuted=${micShouldBeMuted}, vidShouldBeMuted=${vidShouldBeMuted})`,\n            );\n            setTracksEnabled(stream.getAudioTracks(), !micShouldBeMuted);\n            setTracksEnabled(stream.getVideoTracks(), !vidShouldBeMuted);\n            this.client.getMediaHandler().stopUserMediaStream(oldStream);\n        }\n    }\n\n    public async enter(): Promise<void> {\n        if (this.state === GroupCallState.LocalCallFeedUninitialized) {\n            await this.initLocalCallFeed();\n        } else if (this.state !== GroupCallState.LocalCallFeedInitialized) {\n            throw new Error(`Cannot enter call in the \"${this.state}\" state`);\n        }\n\n        logger.log(`GroupCall ${this.groupCallId} enter() running`);\n        this.state = GroupCallState.Entered;\n\n        this.client.on(CallEventHandlerEvent.Incoming, this.onIncomingCall);\n\n        for (const call of this.client.callEventHandler!.calls.values()) {\n            this.onIncomingCall(call);\n        }\n\n        if (!this.useLivekit) {\n            this.retryCallLoopInterval = setInterval(this.onRetryCallLoop, this.retryCallInterval);\n\n            this.activeSpeaker = undefined;\n            this.onActiveSpeakerLoop();\n            this.activeSpeakerLoopInterval = setInterval(this.onActiveSpeakerLoop, this.activeSpeakerInterval);\n        }\n    }\n\n    private dispose(): void {\n        if (this.localCallFeed) {\n            this.removeUserMediaFeed(this.localCallFeed);\n            this.localCallFeed = undefined;\n        }\n\n        if (this.localScreenshareFeed) {\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed.stream);\n            this.removeScreenshareFeed(this.localScreenshareFeed);\n            this.localScreenshareFeed = undefined;\n            this.localDesktopCapturerSourceId = undefined;\n        }\n\n        this.client.getMediaHandler().stopAllStreams();\n\n        if (this.transmitTimer !== null) {\n            clearTimeout(this.transmitTimer);\n            this.transmitTimer = null;\n        }\n\n        if (this.retryCallLoopInterval !== undefined) {\n            clearInterval(this.retryCallLoopInterval);\n            this.retryCallLoopInterval = undefined;\n        }\n\n        if (this.participantsExpirationTimer !== null) {\n            clearTimeout(this.participantsExpirationTimer);\n            this.participantsExpirationTimer = null;\n        }\n\n        if (this.state !== GroupCallState.Entered) {\n            return;\n        }\n\n        this.forEachCall((call) => call.hangup(CallErrorCode.UserHangup, false));\n\n        this.activeSpeaker = undefined;\n        clearInterval(this.activeSpeakerLoopInterval);\n\n        this.retryCallCounts.clear();\n        clearInterval(this.retryCallLoopInterval);\n\n        this.client.removeListener(CallEventHandlerEvent.Incoming, this.onIncomingCall);\n        this.stats?.stop();\n    }\n\n    public leave(): void {\n        this.dispose();\n        this.state = GroupCallState.LocalCallFeedUninitialized;\n    }\n\n    public async terminate(emitStateEvent = true): Promise<void> {\n        this.dispose();\n\n        this.room.off(RoomStateEvent.Update, this.onRoomState);\n        this.client.groupCallEventHandler!.groupCalls.delete(this.room.roomId);\n        this.client.emit(GroupCallEventHandlerEvent.Ended, this);\n        this.state = GroupCallState.Ended;\n\n        if (emitStateEvent) {\n            const existingStateEvent = this.room.currentState.getStateEvents(\n                EventType.GroupCallPrefix,\n                this.groupCallId,\n            )!;\n\n            await this.client.sendStateEvent(\n                this.room.roomId,\n                EventType.GroupCallPrefix,\n                {\n                    ...existingStateEvent.getContent(),\n                    \"m.terminated\": GroupCallTerminationReason.CallEnded,\n                },\n                this.groupCallId,\n            );\n        }\n    }\n\n    /*\n     * Local Usermedia\n     */\n\n    public isLocalVideoMuted(): boolean {\n        if (this.localCallFeed) {\n            return this.localCallFeed.isVideoMuted();\n        }\n\n        return true;\n    }\n\n    public isMicrophoneMuted(): boolean {\n        if (this.localCallFeed) {\n            return this.localCallFeed.isAudioMuted();\n        }\n\n        return true;\n    }\n\n    /**\n     * Sets the mute state of the local participants's microphone.\n     * @param muted - Whether to mute the microphone\n     * @returns Whether muting/unmuting was successful\n     */\n    public async setMicrophoneMuted(muted: boolean): Promise<boolean> {\n        // hasAudioDevice can block indefinitely if the window has lost focus,\n        // and it doesn't make much sense to keep a device from being muted, so\n        // we always allow muted = true changes to go through\n        if (!muted && !(await this.client.getMediaHandler().hasAudioDevice())) {\n            return false;\n        }\n\n        const sendUpdatesBefore = !muted && this.isPtt;\n\n        // set a timer for the maximum transmit time on PTT calls\n        if (this.isPtt) {\n            // Set or clear the max transmit timer\n            if (!muted && this.isMicrophoneMuted()) {\n                this.transmitTimer = setTimeout(() => {\n                    this.setMicrophoneMuted(true);\n                }, this.pttMaxTransmitTime);\n            } else if (muted && !this.isMicrophoneMuted()) {\n                if (this.transmitTimer !== null) clearTimeout(this.transmitTimer);\n                this.transmitTimer = null;\n            }\n        }\n\n        this.forEachCall((call) => call.localUsermediaFeed?.setAudioVideoMuted(muted, null));\n\n        const sendUpdates = async (): Promise<void> => {\n            const updates: Promise<void>[] = [];\n            this.forEachCall((call) => updates.push(call.sendMetadataUpdate()));\n\n            await Promise.all(updates).catch((e) =>\n                logger.info(\n                    `GroupCall ${this.groupCallId} setMicrophoneMuted() failed to send some metadata updates`,\n                    e,\n                ),\n            );\n        };\n\n        if (sendUpdatesBefore) await sendUpdates();\n\n        if (this.localCallFeed) {\n            logger.log(\n                `GroupCall ${this.groupCallId} setMicrophoneMuted() (streamId=${this.localCallFeed.stream.id}, muted=${muted})`,\n            );\n\n            const hasPermission = await this.checkAudioPermissionIfNecessary(muted);\n\n            if (!hasPermission) {\n                return false;\n            }\n\n            this.localCallFeed.setAudioVideoMuted(muted, null);\n            // I don't believe its actually necessary to enable these tracks: they\n            // are the one on the GroupCall's own CallFeed and are cloned before being\n            // given to any of the actual calls, so these tracks don't actually go\n            // anywhere. Let's do it anyway to avoid confusion.\n            setTracksEnabled(this.localCallFeed.stream.getAudioTracks(), !muted);\n        } else {\n            logger.log(`GroupCall ${this.groupCallId} setMicrophoneMuted() no stream muted (muted=${muted})`);\n            this.initWithAudioMuted = muted;\n        }\n\n        this.forEachCall((call) =>\n            setTracksEnabled(call.localUsermediaFeed!.stream.getAudioTracks(), !muted && this.callExpected(call)),\n        );\n        this.emit(GroupCallEvent.LocalMuteStateChanged, muted, this.isLocalVideoMuted());\n\n        if (!sendUpdatesBefore) await sendUpdates();\n\n        return true;\n    }\n\n    /**\n     * If we allow entering a call without a camera and without video, it can happen that the access rights to the\n     * devices have not yet been queried. If a stream does not yet have an audio track, we assume that the rights have\n     * not yet been checked.\n     *\n     * `this.client.getMediaHandler().getUserMediaStream` clones the current stream, so it only wanted to be called when\n     * not Audio Track exists.\n     * As such, this is a compromise, because, the access rights should always be queried before the call.\n     */\n    private async checkAudioPermissionIfNecessary(muted: boolean): Promise<boolean> {\n        // We needed this here to avoid an error in case user join a call without a device.\n        try {\n            if (!muted && this.localCallFeed && !this.localCallFeed.hasAudioTrack) {\n                const stream = await this.client\n                    .getMediaHandler()\n                    .getUserMediaStream(true, !this.localCallFeed.isVideoMuted());\n                if (stream?.getTracks().length === 0) {\n                    // if case permission denied to get a stream stop this here\n                    /* istanbul ignore next */\n                    logger.log(\n                        `GroupCall ${this.groupCallId} setMicrophoneMuted() no device to receive local stream, muted=${muted}`,\n                    );\n                    return false;\n                }\n            }\n        } catch {\n            /* istanbul ignore next */\n            logger.log(\n                `GroupCall ${this.groupCallId} setMicrophoneMuted() no device or permission to receive local stream, muted=${muted}`,\n            );\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Sets the mute state of the local participants's video.\n     * @param muted - Whether to mute the video\n     * @returns Whether muting/unmuting was successful\n     */\n    public async setLocalVideoMuted(muted: boolean): Promise<boolean> {\n        // hasAudioDevice can block indefinitely if the window has lost focus,\n        // and it doesn't make much sense to keep a device from being muted, so\n        // we always allow muted = true changes to go through\n        if (!muted && !(await this.client.getMediaHandler().hasVideoDevice())) {\n            return false;\n        }\n\n        if (this.localCallFeed) {\n            /* istanbul ignore next */\n            logger.log(\n                `GroupCall ${this.groupCallId} setLocalVideoMuted() (stream=${this.localCallFeed.stream.id}, muted=${muted})`,\n            );\n\n            try {\n                const stream = await this.client.getMediaHandler().getUserMediaStream(true, !muted);\n                await this.updateLocalUsermediaStream(stream);\n                this.localCallFeed.setAudioVideoMuted(null, muted);\n                setTracksEnabled(this.localCallFeed.stream.getVideoTracks(), !muted);\n            } catch {\n                // No permission to video device\n                /* istanbul ignore next */\n                logger.log(\n                    `GroupCall ${this.groupCallId} setLocalVideoMuted() no device or permission to receive local stream, muted=${muted}`,\n                );\n                return false;\n            }\n        } else {\n            logger.log(`GroupCall ${this.groupCallId} setLocalVideoMuted() no stream muted (muted=${muted})`);\n            this.initWithVideoMuted = muted;\n        }\n\n        const updates: Promise<unknown>[] = [];\n        this.forEachCall((call) => updates.push(call.setLocalVideoMuted(muted)));\n        await Promise.all(updates);\n\n        // We setTracksEnabled again, independently from the call doing it\n        // internally, since we might not be expecting the call\n        this.forEachCall((call) =>\n            setTracksEnabled(call.localUsermediaFeed!.stream.getVideoTracks(), !muted && this.callExpected(call)),\n        );\n\n        this.emit(GroupCallEvent.LocalMuteStateChanged, this.isMicrophoneMuted(), muted);\n\n        return true;\n    }\n\n    public async setScreensharingEnabled(enabled: boolean, opts: IScreensharingOpts = {}): Promise<boolean> {\n        if (enabled === this.isScreensharing()) {\n            return enabled;\n        }\n\n        if (enabled) {\n            try {\n                logger.log(\n                    `GroupCall ${this.groupCallId} setScreensharingEnabled() is asking for screensharing permissions`,\n                );\n                const stream = await this.client.getMediaHandler().getScreensharingStream(opts);\n\n                for (const track of stream.getTracks()) {\n                    const onTrackEnded = (): void => {\n                        this.setScreensharingEnabled(false);\n                        track.removeEventListener(\"ended\", onTrackEnded);\n                    };\n\n                    track.addEventListener(\"ended\", onTrackEnded);\n                }\n\n                logger.log(\n                    `GroupCall ${this.groupCallId} setScreensharingEnabled() granted screensharing permissions. Setting screensharing enabled on all calls`,\n                );\n\n                this.localDesktopCapturerSourceId = opts.desktopCapturerSourceId;\n                this.localScreenshareFeed = new CallFeed({\n                    client: this.client,\n                    roomId: this.room.roomId,\n                    userId: this.client.getUserId()!,\n                    deviceId: this.client.getDeviceId()!,\n                    stream,\n                    purpose: SDPStreamMetadataPurpose.Screenshare,\n                    audioMuted: false,\n                    videoMuted: false,\n                });\n                this.addScreenshareFeed(this.localScreenshareFeed);\n\n                this.emit(\n                    GroupCallEvent.LocalScreenshareStateChanged,\n                    true,\n                    this.localScreenshareFeed,\n                    this.localDesktopCapturerSourceId,\n                );\n\n                // TODO: handle errors\n                this.forEachCall((call) => call.pushLocalFeed(this.localScreenshareFeed!.clone()));\n\n                return true;\n            } catch (error) {\n                if (opts.throwOnFail) throw error;\n                logger.error(\n                    `GroupCall ${this.groupCallId} setScreensharingEnabled() enabling screensharing error`,\n                    error,\n                );\n                this.emit(\n                    GroupCallEvent.Error,\n                    new GroupCallError(\n                        GroupCallErrorCode.NoUserMedia,\n                        \"Failed to get screen-sharing stream: \",\n                        error as Error,\n                    ),\n                );\n                return false;\n            }\n        } else {\n            this.forEachCall((call) => {\n                if (call.localScreensharingFeed) call.removeLocalFeed(call.localScreensharingFeed);\n            });\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed!.stream);\n            this.removeScreenshareFeed(this.localScreenshareFeed!);\n            this.localScreenshareFeed = undefined;\n            this.localDesktopCapturerSourceId = undefined;\n            this.emit(GroupCallEvent.LocalScreenshareStateChanged, false, undefined, undefined);\n            return false;\n        }\n    }\n\n    public isScreensharing(): boolean {\n        return !!this.localScreenshareFeed;\n    }\n\n    /*\n     * Call Setup\n     *\n     * There are two different paths for calls to be created:\n     * 1. Incoming calls triggered by the Call.incoming event.\n     * 2. Outgoing calls to the initial members of a room or new members\n     *    as they are observed by the RoomState.members event.\n     */\n\n    private onIncomingCall = (newCall: MatrixCall): void => {\n        // The incoming calls may be for another room, which we will ignore.\n        if (newCall.roomId !== this.room.roomId) {\n            return;\n        }\n\n        if (newCall.state !== CallState.Ringing) {\n            logger.warn(\n                `GroupCall ${this.groupCallId} onIncomingCall() incoming call no longer in ringing state - ignoring`,\n            );\n            return;\n        }\n\n        if (!newCall.groupCallId || newCall.groupCallId !== this.groupCallId) {\n            logger.log(\n                `GroupCall ${this.groupCallId} onIncomingCall() ignored because it doesn't match the current group call`,\n            );\n            newCall.reject();\n            return;\n        }\n\n        const opponentUserId = newCall.getOpponentMember()?.userId;\n        if (opponentUserId === undefined) {\n            logger.warn(`GroupCall ${this.groupCallId} onIncomingCall() incoming call with no member - ignoring`);\n            return;\n        }\n\n        if (this.useLivekit) {\n            logger.info(\"Received incoming call whilst in signaling-only mode! Ignoring.\");\n            return;\n        }\n\n        const deviceMap = this.calls.get(opponentUserId) ?? new Map<string, MatrixCall>();\n        const prevCall = deviceMap.get(newCall.getOpponentDeviceId()!);\n\n        if (prevCall?.callId === newCall.callId) return;\n\n        logger.log(\n            `GroupCall ${this.groupCallId} onIncomingCall() incoming call (userId=${opponentUserId}, callId=${newCall.callId})`,\n        );\n\n        if (prevCall) prevCall.hangup(CallErrorCode.Replaced, false);\n        // We must do this before we start initialising / answering the call as we\n        // need to know it is the active call for this user+deviceId and to not ignore\n        // events from it.\n        deviceMap.set(newCall.getOpponentDeviceId()!, newCall);\n        this.calls.set(opponentUserId, deviceMap);\n\n        this.initCall(newCall);\n\n        const feeds = this.getLocalFeeds().map((feed) => feed.clone());\n        if (!this.callExpected(newCall)) {\n            // Disable our tracks for users not explicitly participating in the\n            // call but trying to receive the feeds\n            for (const feed of feeds) {\n                setTracksEnabled(feed.stream.getAudioTracks(), false);\n                setTracksEnabled(feed.stream.getVideoTracks(), false);\n            }\n        }\n        newCall.answerWithCallFeeds(feeds);\n\n        this.emit(GroupCallEvent.CallsChanged, this.calls);\n    };\n\n    /**\n     * Determines whether a given participant expects us to call them (versus\n     * them calling us).\n     * @param userId - The participant's user ID.\n     * @param deviceId - The participant's device ID.\n     * @returns Whether we need to place an outgoing call to the participant.\n     */\n    private wantsOutgoingCall(userId: string, deviceId: string): boolean {\n        const localUserId = this.client.getUserId()!;\n        const localDeviceId = this.client.getDeviceId()!;\n        return (\n            // If a user's ID is less than our own, they'll call us\n            userId >= localUserId &&\n            // If this is another one of our devices, compare device IDs to tell whether it'll call us\n            (userId !== localUserId || deviceId > localDeviceId)\n        );\n    }\n\n    /**\n     * Places calls to all participants that we're responsible for calling.\n     */\n    private placeOutgoingCalls(): void {\n        let callsChanged = false;\n\n        for (const [{ userId }, participantMap] of this.participants) {\n            const callMap = this.calls.get(userId) ?? new Map<string, MatrixCall>();\n\n            for (const [deviceId, participant] of participantMap) {\n                const prevCall = callMap.get(deviceId);\n\n                if (\n                    prevCall?.getOpponentSessionId() !== participant.sessionId &&\n                    this.wantsOutgoingCall(userId, deviceId)\n                ) {\n                    callsChanged = true;\n\n                    if (prevCall !== undefined) {\n                        logger.debug(\n                            `GroupCall ${this.groupCallId} placeOutgoingCalls() replacing call (userId=${userId}, deviceId=${deviceId}, callId=${prevCall.callId})`,\n                        );\n                        prevCall.hangup(CallErrorCode.NewSession, false);\n                    }\n\n                    const newCall = createNewMatrixCall(this.client, this.room.roomId, {\n                        invitee: userId,\n                        opponentDeviceId: deviceId,\n                        opponentSessionId: participant.sessionId,\n                        groupCallId: this.groupCallId,\n                    });\n\n                    if (newCall === null) {\n                        logger.error(\n                            `GroupCall ${this.groupCallId} placeOutgoingCalls() failed to create call (userId=${userId}, device=${deviceId})`,\n                        );\n                        callMap.delete(deviceId);\n                    } else {\n                        this.initCall(newCall);\n                        callMap.set(deviceId, newCall);\n\n                        logger.debug(\n                            `GroupCall ${this.groupCallId} placeOutgoingCalls() placing call (userId=${userId}, deviceId=${deviceId}, sessionId=${participant.sessionId})`,\n                        );\n\n                        newCall\n                            .placeCallWithCallFeeds(\n                                this.getLocalFeeds().map((feed) => feed.clone()),\n                                participant.screensharing,\n                            )\n                            .then(() => {\n                                if (this.dataChannelsEnabled) {\n                                    newCall.createDataChannel(\"datachannel\", this.dataChannelOptions);\n                                }\n                            })\n                            .catch((e) => {\n                                logger.warn(\n                                    `GroupCall ${this.groupCallId} placeOutgoingCalls() failed to place call (userId=${userId})`,\n                                    e,\n                                );\n\n                                if (e instanceof CallError && e.code === GroupCallErrorCode.UnknownDevice) {\n                                    this.emit(GroupCallEvent.Error, e);\n                                } else {\n                                    this.emit(\n                                        GroupCallEvent.Error,\n                                        new GroupCallError(\n                                            GroupCallErrorCode.PlaceCallFailed,\n                                            `Failed to place call to ${userId}`,\n                                        ),\n                                    );\n                                }\n\n                                newCall.hangup(CallErrorCode.SignallingFailed, false);\n                                if (callMap.get(deviceId) === newCall) callMap.delete(deviceId);\n                            });\n                    }\n                }\n            }\n\n            if (callMap.size > 0) {\n                this.calls.set(userId, callMap);\n            } else {\n                this.calls.delete(userId);\n            }\n        }\n\n        if (callsChanged) this.emit(GroupCallEvent.CallsChanged, this.calls);\n    }\n\n    /*\n     * Room Member State\n     */\n\n    private getMemberStateEvents(): MatrixEvent[];\n    private getMemberStateEvents(userId: string): MatrixEvent | null;\n    private getMemberStateEvents(userId?: string): MatrixEvent[] | MatrixEvent | null {\n        return userId === undefined\n            ? this.room.currentState.getStateEvents(EventType.GroupCallMemberPrefix)\n            : this.room.currentState.getStateEvents(EventType.GroupCallMemberPrefix, userId);\n    }\n\n    private onRetryCallLoop = (): void => {\n        let needsRetry = false;\n\n        for (const [{ userId }, participantMap] of this.participants) {\n            const callMap = this.calls.get(userId);\n            let retriesMap = this.retryCallCounts.get(userId);\n\n            for (const [deviceId, participant] of participantMap) {\n                const call = callMap?.get(deviceId);\n                const retries = retriesMap?.get(deviceId) ?? 0;\n\n                if (\n                    call?.getOpponentSessionId() !== participant.sessionId &&\n                    this.wantsOutgoingCall(userId, deviceId) &&\n                    retries < 3\n                ) {\n                    if (retriesMap === undefined) {\n                        retriesMap = new Map();\n                        this.retryCallCounts.set(userId, retriesMap);\n                    }\n                    retriesMap.set(deviceId, retries + 1);\n                    needsRetry = true;\n                }\n            }\n        }\n\n        if (needsRetry) this.placeOutgoingCalls();\n    };\n\n    private initCall(call: MatrixCall): void {\n        const opponentMemberId = getCallUserId(call);\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot init call without user id\");\n        }\n\n        const onCallFeedsChanged = (): void => this.onCallFeedsChanged(call);\n        const onCallStateChanged = (state: CallState, oldState?: CallState): void =>\n            this.onCallStateChanged(call, state, oldState);\n        const onCallHangup = this.onCallHangup;\n        const onCallReplaced = (newCall: MatrixCall): void => this.onCallReplaced(call, newCall);\n\n        let deviceMap = this.callHandlers.get(opponentMemberId);\n        if (deviceMap === undefined) {\n            deviceMap = new Map();\n            this.callHandlers.set(opponentMemberId, deviceMap);\n        }\n\n        deviceMap.set(call.getOpponentDeviceId()!, {\n            onCallFeedsChanged,\n            onCallStateChanged,\n            onCallHangup,\n            onCallReplaced,\n        });\n\n        call.on(CallEvent.FeedsChanged, onCallFeedsChanged);\n        call.on(CallEvent.State, onCallStateChanged);\n        call.on(CallEvent.Hangup, onCallHangup);\n        call.on(CallEvent.Replaced, onCallReplaced);\n\n        call.isPtt = this.isPtt;\n\n        this.reEmitter.reEmit(call, Object.values(CallEvent));\n\n        call.initStats(this.getGroupCallStats());\n\n        onCallFeedsChanged();\n    }\n\n    private disposeCall(call: MatrixCall, hangupReason: CallErrorCode): void {\n        const opponentMemberId = getCallUserId(call);\n        const opponentDeviceId = call.getOpponentDeviceId()!;\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot dispose call without user id\");\n        }\n\n        const deviceMap = this.callHandlers.get(opponentMemberId)!;\n        const { onCallFeedsChanged, onCallStateChanged, onCallHangup, onCallReplaced } =\n            deviceMap.get(opponentDeviceId)!;\n\n        call.removeListener(CallEvent.FeedsChanged, onCallFeedsChanged);\n        call.removeListener(CallEvent.State, onCallStateChanged);\n        call.removeListener(CallEvent.Hangup, onCallHangup);\n        call.removeListener(CallEvent.Replaced, onCallReplaced);\n\n        deviceMap.delete(opponentMemberId);\n        if (deviceMap.size === 0) this.callHandlers.delete(opponentMemberId);\n\n        if (call.hangupReason === CallErrorCode.Replaced) {\n            return;\n        }\n\n        const usermediaFeed = this.getUserMediaFeed(opponentMemberId, opponentDeviceId);\n\n        if (usermediaFeed) {\n            this.removeUserMediaFeed(usermediaFeed);\n        }\n\n        const screenshareFeed = this.getScreenshareFeed(opponentMemberId, opponentDeviceId);\n\n        if (screenshareFeed) {\n            this.removeScreenshareFeed(screenshareFeed);\n        }\n    }\n\n    private onCallFeedsChanged = (call: MatrixCall): void => {\n        const opponentMemberId = getCallUserId(call);\n        const opponentDeviceId = call.getOpponentDeviceId()!;\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot change call feeds without user id\");\n        }\n\n        const currentUserMediaFeed = this.getUserMediaFeed(opponentMemberId, opponentDeviceId);\n        const remoteUsermediaFeed = call.remoteUsermediaFeed;\n        const remoteFeedChanged = remoteUsermediaFeed !== currentUserMediaFeed;\n\n        const deviceMap = this.calls.get(opponentMemberId);\n        const currentCallForUserDevice = deviceMap?.get(opponentDeviceId);\n        if (currentCallForUserDevice?.callId !== call.callId) {\n            // the call in question is not the current call for this user/deviceId\n            // so ignore feed events from it otherwise we'll remove our real feeds\n            return;\n        }\n\n        if (remoteFeedChanged) {\n            if (!currentUserMediaFeed && remoteUsermediaFeed) {\n                this.addUserMediaFeed(remoteUsermediaFeed);\n            } else if (currentUserMediaFeed && remoteUsermediaFeed) {\n                this.replaceUserMediaFeed(currentUserMediaFeed, remoteUsermediaFeed);\n            } else if (currentUserMediaFeed && !remoteUsermediaFeed) {\n                this.removeUserMediaFeed(currentUserMediaFeed);\n            }\n        }\n\n        const currentScreenshareFeed = this.getScreenshareFeed(opponentMemberId, opponentDeviceId);\n        const remoteScreensharingFeed = call.remoteScreensharingFeed;\n        const remoteScreenshareFeedChanged = remoteScreensharingFeed !== currentScreenshareFeed;\n\n        if (remoteScreenshareFeedChanged) {\n            if (!currentScreenshareFeed && remoteScreensharingFeed) {\n                this.addScreenshareFeed(remoteScreensharingFeed);\n            } else if (currentScreenshareFeed && remoteScreensharingFeed) {\n                this.replaceScreenshareFeed(currentScreenshareFeed, remoteScreensharingFeed);\n            } else if (currentScreenshareFeed && !remoteScreensharingFeed) {\n                this.removeScreenshareFeed(currentScreenshareFeed);\n            }\n        }\n    };\n\n    private onCallStateChanged = (call: MatrixCall, state: CallState, _oldState: CallState | undefined): void => {\n        if (state === CallState.Ended) return;\n\n        const audioMuted = this.localCallFeed!.isAudioMuted();\n\n        if (call.localUsermediaStream && call.isMicrophoneMuted() !== audioMuted) {\n            call.setMicrophoneMuted(audioMuted);\n        }\n\n        const videoMuted = this.localCallFeed!.isVideoMuted();\n\n        if (call.localUsermediaStream && call.isLocalVideoMuted() !== videoMuted) {\n            call.setLocalVideoMuted(videoMuted);\n        }\n\n        const opponentUserId = call.getOpponentMember()?.userId;\n        if (state === CallState.Connected && opponentUserId) {\n            const retriesMap = this.retryCallCounts.get(opponentUserId);\n            retriesMap?.delete(call.getOpponentDeviceId()!);\n            if (retriesMap?.size === 0) this.retryCallCounts.delete(opponentUserId);\n        }\n    };\n\n    private onCallHangup = (call: MatrixCall): void => {\n        if (call.hangupReason === CallErrorCode.Replaced) return;\n\n        const opponentUserId = call.getOpponentMember()?.userId ?? this.room.getMember(call.invitee!)!.userId;\n        const deviceMap = this.calls.get(opponentUserId);\n\n        // Sanity check that this call is in fact in the map\n        if (deviceMap?.get(call.getOpponentDeviceId()!) === call) {\n            this.disposeCall(call, call.hangupReason as CallErrorCode);\n            deviceMap.delete(call.getOpponentDeviceId()!);\n            if (deviceMap.size === 0) this.calls.delete(opponentUserId);\n            this.emit(GroupCallEvent.CallsChanged, this.calls);\n        }\n    };\n\n    private onCallReplaced = (prevCall: MatrixCall, newCall: MatrixCall): void => {\n        const opponentUserId = prevCall.getOpponentMember()!.userId;\n\n        let deviceMap = this.calls.get(opponentUserId);\n        if (deviceMap === undefined) {\n            deviceMap = new Map();\n            this.calls.set(opponentUserId, deviceMap);\n        }\n\n        prevCall.hangup(CallErrorCode.Replaced, false);\n        this.initCall(newCall);\n        deviceMap.set(prevCall.getOpponentDeviceId()!, newCall);\n        this.emit(GroupCallEvent.CallsChanged, this.calls);\n    };\n\n    /*\n     * UserMedia CallFeed Event Handlers\n     */\n\n    public getUserMediaFeed(userId: string, deviceId: string): CallFeed | undefined {\n        return this.userMediaFeeds.find((f) => f.userId === userId && f.deviceId! === deviceId);\n    }\n\n    private addUserMediaFeed(callFeed: CallFeed): void {\n        this.userMediaFeeds.push(callFeed);\n        callFeed.measureVolumeActivity(true);\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n    }\n\n    private replaceUserMediaFeed(existingFeed: CallFeed, replacementFeed: CallFeed): void {\n        const feedIndex = this.userMediaFeeds.findIndex(\n            (f) => f.userId === existingFeed.userId && f.deviceId! === existingFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find user media feed to replace\");\n        }\n\n        this.userMediaFeeds.splice(feedIndex, 1, replacementFeed);\n\n        existingFeed.dispose();\n        replacementFeed.measureVolumeActivity(true);\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n    }\n\n    private removeUserMediaFeed(callFeed: CallFeed): void {\n        const feedIndex = this.userMediaFeeds.findIndex(\n            (f) => f.userId === callFeed.userId && f.deviceId! === callFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find user media feed to remove\");\n        }\n\n        this.userMediaFeeds.splice(feedIndex, 1);\n\n        callFeed.dispose();\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n\n        if (this.activeSpeaker === callFeed) {\n            this.activeSpeaker = this.userMediaFeeds[0];\n            this.emit(GroupCallEvent.ActiveSpeakerChanged, this.activeSpeaker);\n        }\n    }\n\n    private onActiveSpeakerLoop = (): void => {\n        let topAvg: number | undefined = undefined;\n        let nextActiveSpeaker: CallFeed | undefined = undefined;\n\n        for (const callFeed of this.userMediaFeeds) {\n            if (callFeed.isLocal() && this.userMediaFeeds.length > 1) continue;\n\n            const total = callFeed.speakingVolumeSamples.reduce(\n                (acc, volume) => acc + Math.max(volume, SPEAKING_THRESHOLD),\n            );\n            const avg = total / callFeed.speakingVolumeSamples.length;\n\n            if (!topAvg || avg > topAvg) {\n                topAvg = avg;\n                nextActiveSpeaker = callFeed;\n            }\n        }\n\n        if (nextActiveSpeaker && this.activeSpeaker !== nextActiveSpeaker && topAvg && topAvg > SPEAKING_THRESHOLD) {\n            this.activeSpeaker = nextActiveSpeaker;\n            this.emit(GroupCallEvent.ActiveSpeakerChanged, this.activeSpeaker);\n        }\n    };\n\n    /*\n     * Screenshare Call Feed Event Handlers\n     */\n\n    public getScreenshareFeed(userId: string, deviceId: string): CallFeed | undefined {\n        return this.screenshareFeeds.find((f) => f.userId === userId && f.deviceId! === deviceId);\n    }\n\n    private addScreenshareFeed(callFeed: CallFeed): void {\n        this.screenshareFeeds.push(callFeed);\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    private replaceScreenshareFeed(existingFeed: CallFeed, replacementFeed: CallFeed): void {\n        const feedIndex = this.screenshareFeeds.findIndex(\n            (f) => f.userId === existingFeed.userId && f.deviceId! === existingFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find screenshare feed to replace\");\n        }\n\n        this.screenshareFeeds.splice(feedIndex, 1, replacementFeed);\n\n        existingFeed.dispose();\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    private removeScreenshareFeed(callFeed: CallFeed): void {\n        const feedIndex = this.screenshareFeeds.findIndex(\n            (f) => f.userId === callFeed.userId && f.deviceId! === callFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find screenshare feed to remove\");\n        }\n\n        this.screenshareFeeds.splice(feedIndex, 1);\n\n        callFeed.dispose();\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    /**\n     * Recalculates and updates the participant map to match the room state.\n     */\n    private updateParticipants(): void {\n        const localMember = this.room.getMember(this.client.getSafeUserId());\n        if (!localMember) {\n            // The client hasn't fetched enough of the room state to get our own member\n            // event. This probably shouldn't happen, but sanity check & exit for now.\n            logger.warn(\n                `GroupCall ${this.groupCallId} updateParticipants() tried to update participants before local room member is available`,\n            );\n            return;\n        }\n\n        if (this.participantsExpirationTimer !== null) {\n            clearTimeout(this.participantsExpirationTimer);\n            this.participantsExpirationTimer = null;\n        }\n\n        if (this.state === GroupCallState.Ended) {\n            this.participants = new Map();\n            return;\n        }\n\n        const participants = new Map<RoomMember, Map<string, ParticipantState>>();\n        const now = Date.now();\n        const entered = this.state === GroupCallState.Entered || this.enteredViaAnotherSession;\n        let nextExpiration = Infinity;\n\n        for (const e of this.getMemberStateEvents()) {\n            const member = this.room.getMember(e.getStateKey()!);\n            const content = e.getContent<Record<any, unknown>>();\n            const calls: Record<any, unknown>[] = Array.isArray(content[\"m.calls\"]) ? content[\"m.calls\"] : [];\n            const call = calls.find((call) => call[\"m.call_id\"] === this.groupCallId);\n            const devices: Record<any, unknown>[] = Array.isArray(call?.[\"m.devices\"]) ? call![\"m.devices\"] : [];\n\n            // Filter out invalid and expired devices\n            let validDevices = devices.filter(\n                (d) =>\n                    typeof d.device_id === \"string\" &&\n                    typeof d.session_id === \"string\" &&\n                    typeof d.expires_ts === \"number\" &&\n                    d.expires_ts > now &&\n                    Array.isArray(d.feeds),\n            ) as unknown as IGroupCallRoomMemberDevice[];\n\n            // Apply local echo for the unentered case\n            if (!entered && member?.userId === this.client.getUserId()!) {\n                validDevices = validDevices.filter((d) => d.device_id !== this.client.getDeviceId()!);\n            }\n\n            // Must have a connected device and be joined to the room\n            if (validDevices.length > 0 && member?.membership === KnownMembership.Join) {\n                const deviceMap = new Map<string, ParticipantState>();\n                participants.set(member, deviceMap);\n\n                for (const d of validDevices) {\n                    deviceMap.set(d.device_id, {\n                        sessionId: d.session_id,\n                        screensharing: d.feeds.some((f) => f.purpose === SDPStreamMetadataPurpose.Screenshare),\n                    });\n                    if (d.expires_ts < nextExpiration) nextExpiration = d.expires_ts;\n                }\n            }\n        }\n\n        // Apply local echo for the entered case\n        if (entered) {\n            let deviceMap = participants.get(localMember);\n            if (deviceMap === undefined) {\n                deviceMap = new Map();\n                participants.set(localMember, deviceMap);\n            }\n\n            if (!deviceMap.has(this.client.getDeviceId()!)) {\n                deviceMap.set(this.client.getDeviceId()!, {\n                    sessionId: this.client.getSessionId(),\n                    screensharing: this.getLocalFeeds().some((f) => f.purpose === SDPStreamMetadataPurpose.Screenshare),\n                });\n            }\n        }\n\n        this.participants = participants;\n        if (nextExpiration < Infinity) {\n            this.participantsExpirationTimer = setTimeout(() => this.updateParticipants(), nextExpiration - now);\n        }\n    }\n\n    /**\n     * Updates the local user's member state with the devices returned by the given function.\n     * @param fn - A function from the current devices to the new devices. If it\n     *   returns null, the update will be skipped.\n     * @param keepAlive - Whether the request should outlive the window.\n     */\n    private async updateDevices(\n        fn: (devices: IGroupCallRoomMemberDevice[]) => IGroupCallRoomMemberDevice[] | null,\n        keepAlive = false,\n    ): Promise<void> {\n        const now = Date.now();\n        const localUserId = this.client.getUserId()!;\n\n        const event = this.getMemberStateEvents(localUserId);\n        const content = event?.getContent<Record<any, unknown>>() ?? {};\n        const calls: Record<any, unknown>[] = Array.isArray(content[\"m.calls\"]) ? content[\"m.calls\"] : [];\n\n        let call: Record<any, unknown> | null = null;\n        const otherCalls: Record<any, unknown>[] = [];\n        for (const c of calls) {\n            if (c[\"m.call_id\"] === this.groupCallId) {\n                call = c;\n            } else {\n                otherCalls.push(c);\n            }\n        }\n        if (call === null) call = {};\n\n        const devices: Record<any, unknown>[] = Array.isArray(call[\"m.devices\"]) ? call[\"m.devices\"] : [];\n\n        // Filter out invalid and expired devices\n        const validDevices = devices.filter(\n            (d) =>\n                typeof d.device_id === \"string\" &&\n                typeof d.session_id === \"string\" &&\n                typeof d.expires_ts === \"number\" &&\n                d.expires_ts > now &&\n                Array.isArray(d.feeds),\n        ) as unknown as IGroupCallRoomMemberDevice[];\n\n        const newDevices = fn(validDevices);\n        if (newDevices === null) return;\n\n        const newCalls = [...(otherCalls as unknown as IGroupCallRoomMemberCallState[])];\n        if (newDevices.length > 0) {\n            newCalls.push({\n                ...call,\n                \"m.call_id\": this.groupCallId,\n                \"m.devices\": newDevices,\n            });\n        }\n\n        const newContent: IGroupCallRoomMemberState = { \"m.calls\": newCalls };\n\n        await this.client.sendStateEvent(this.room.roomId, EventType.GroupCallMemberPrefix, newContent, localUserId, {\n            keepAlive,\n        });\n    }\n\n    private async addDeviceToMemberState(): Promise<void> {\n        await this.updateDevices((devices) => [\n            ...devices.filter((d) => d.device_id !== this.client.getDeviceId()!),\n            {\n                device_id: this.client.getDeviceId()!,\n                session_id: this.client.getSessionId(),\n                expires_ts: Date.now() + DEVICE_TIMEOUT,\n                feeds: this.getLocalFeeds().map((feed) => ({ purpose: feed.purpose })),\n                // TODO: Add data channels\n            },\n        ]);\n    }\n\n    private async updateMemberState(): Promise<void> {\n        // Clear the old update interval before proceeding\n        if (this.resendMemberStateTimer !== null) {\n            clearInterval(this.resendMemberStateTimer);\n            this.resendMemberStateTimer = null;\n        }\n\n        if (this.state === GroupCallState.Entered) {\n            // Add the local device\n            await this.addDeviceToMemberState();\n\n            // Resend the state event every so often so it doesn't become stale\n            this.resendMemberStateTimer = setInterval(\n                async () => {\n                    logger.log(`GroupCall ${this.groupCallId} updateMemberState() resending call member state\"`);\n                    try {\n                        await this.addDeviceToMemberState();\n                    } catch (e) {\n                        logger.error(\n                            `GroupCall ${this.groupCallId} updateMemberState() failed to resend call member state`,\n                            e,\n                        );\n                    }\n                },\n                (DEVICE_TIMEOUT * 3) / 4,\n            );\n        } else {\n            // Remove the local device\n            await this.updateDevices(\n                (devices) => devices.filter((d) => d.device_id !== this.client.getDeviceId()!),\n                true,\n            );\n        }\n    }\n\n    /**\n     * Cleans up our member state by filtering out logged out devices, inactive\n     * devices, and our own device (if we know we haven't entered).\n     */\n    public async cleanMemberState(): Promise<void> {\n        const { devices: myDevices } = await this.client.getDevices();\n        const deviceMap = new Map<string, IMyDevice>(myDevices.map((d) => [d.device_id, d]));\n\n        // updateDevices takes care of filtering out inactive devices for us\n        await this.updateDevices((devices) => {\n            const newDevices = devices.filter((d) => {\n                const device = deviceMap.get(d.device_id);\n                return (\n                    device?.last_seen_ts !== undefined &&\n                    !(\n                        d.device_id === this.client.getDeviceId()! &&\n                        this.state !== GroupCallState.Entered &&\n                        !this.enteredViaAnotherSession\n                    )\n                );\n            });\n\n            // Skip the update if the devices are unchanged\n            return newDevices.length === devices.length ? null : newDevices;\n        });\n    }\n\n    private onRoomState = (): void => this.updateParticipants();\n\n    private onParticipantsChanged = (): void => {\n        // Re-run setTracksEnabled on all calls, so that participants that just\n        // left get denied access to our media, and participants that just\n        // joined get granted access\n        this.forEachCall((call) => {\n            const expected = this.callExpected(call);\n            for (const feed of call.getLocalFeeds()) {\n                setTracksEnabled(feed.stream.getAudioTracks(), !feed.isAudioMuted() && expected);\n                setTracksEnabled(feed.stream.getVideoTracks(), !feed.isVideoMuted() && expected);\n            }\n        });\n\n        if (this.state === GroupCallState.Entered && !this.useLivekit) this.placeOutgoingCalls();\n\n        // Update the participants stored in the stats object\n    };\n\n    private onStateChanged = (newState: GroupCallState, oldState: GroupCallState): void => {\n        if (\n            newState === GroupCallState.Entered ||\n            oldState === GroupCallState.Entered ||\n            newState === GroupCallState.Ended\n        ) {\n            // We either entered, left, or ended the call\n            this.updateParticipants();\n            this.updateMemberState().catch((e) =>\n                logger.error(\n                    `GroupCall ${this.groupCallId} onStateChanged() failed to update member state devices\"`,\n                    e,\n                ),\n            );\n        }\n    };\n\n    private onLocalFeedsChanged = (): void => {\n        if (this.state === GroupCallState.Entered) {\n            this.updateMemberState().catch((e) =>\n                logger.error(\n                    `GroupCall ${this.groupCallId} onLocalFeedsChanged() failed to update member state feeds`,\n                    e,\n                ),\n            );\n        }\n    };\n\n    public getGroupCallStats(): GroupCallStats {\n        if (this.stats === undefined) {\n            const userID = this.client.getUserId() || \"unknown\";\n            this.stats = new GroupCallStats(this.groupCallId, userID, this.statsCollectIntervalTime);\n            this.stats.reports.on(StatsReport.CONNECTION_STATS, this.onConnectionStats);\n            this.stats.reports.on(StatsReport.BYTE_SENT_STATS, this.onByteSentStats);\n            this.stats.reports.on(StatsReport.SUMMARY_STATS, this.onSummaryStats);\n            this.stats.reports.on(StatsReport.CALL_FEED_REPORT, this.onCallFeedReport);\n        }\n        return this.stats;\n    }\n\n    public setGroupCallStatsInterval(interval: number): void {\n        this.statsCollectIntervalTime = interval;\n        if (this.stats !== undefined) {\n            this.stats.stop();\n            this.stats.setInterval(interval);\n            if (interval > 0) {\n                this.stats.start();\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]}